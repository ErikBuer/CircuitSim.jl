<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · CircuitSim.jl</title><meta name="title" content="API Reference · CircuitSim.jl"/><meta property="og:title" content="API Reference · CircuitSim.jl"/><meta property="twitter:title" content="API Reference · CircuitSim.jl"/><meta name="description" content="Documentation for CircuitSim.jl."/><meta property="og:description" content="Documentation for CircuitSim.jl."/><meta property="twitter:description" content="Documentation for CircuitSim.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">CircuitSim.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">CircuitSim.jl</a></li><li><span class="tocitem">Sources</span><ul><li><a class="tocitem" href="../Sources/file_voltage_source/">File Based Voltage Source</a></li><li><a class="tocitem" href="../Sources/file_current_source/">File Based Current Source</a></li><li><a class="tocitem" href="../Sources/voltage_pulse_source/">Voltage Pulse Source</a></li><li><a class="tocitem" href="../Sources/current_pulse_source/">Current Pulse Source</a></li><li><a class="tocitem" href="../Sources/voltage_rectangular_source/">Voltage Rectangular Source</a></li><li><a class="tocitem" href="../Sources/current_rectangular_source/">Current Rectangular Source</a></li><li><a class="tocitem" href="../Sources/voltage_exponential_source/">Voltage Exponential Source</a></li><li><a class="tocitem" href="../Sources/current_exponential_source/">Current Exponential Source</a></li><li><a class="tocitem" href="../Sources/voltage_noise_source/">Voltage Noise Source</a></li><li><a class="tocitem" href="../Sources/current_noise_source/">Current Noise Source</a></li><li><a class="tocitem" href="../Sources/current_controlled_current_source/">Current-Controlled Current Source</a></li><li><a class="tocitem" href="../Sources/current_controlled_voltage_source/">Current-Controlled Voltage Source</a></li><li><a class="tocitem" href="../Sources/voltage_controlled_current_source/">Voltage-Controlled Current Source</a></li><li><a class="tocitem" href="../Sources/voltage_controlled_voltage_source/">Voltage-Controlled Voltage Source</a></li><li><a class="tocitem" href="../Sources/voltage_am_source/">Amplitude Modulated Voltage Source</a></li><li><a class="tocitem" href="../Sources/voltage_pm_source/">Phase Modulated Voltage Source</a></li><li><a class="tocitem" href="../Sources/current_current_noise_source/">Correlated Current-Current Noise Source</a></li><li><a class="tocitem" href="../Sources/current_voltage_noise_source/">Correlated Current-Voltage Noise Source</a></li><li><a class="tocitem" href="../Sources/voltage_voltage_noise_source/">Correlated Voltage-Voltage Noise Source</a></li></ul></li><li><span class="tocitem">Components</span><ul><li><a class="tocitem" href="../Components/resistor/">Resistor</a></li><li><a class="tocitem" href="../Components/capacitor/">Capacitor</a></li><li><a class="tocitem" href="../Components/capacitor_q/">Capacitor with Quality Factor</a></li><li><a class="tocitem" href="../Components/inductor/">Inductor</a></li><li><a class="tocitem" href="../Components/inductor_q/">Inductor with Quality Factor</a></li><li><a class="tocitem" href="../Components/ground/">Ground</a></li><li><a class="tocitem" href="../Components/open/">Open Circuit</a></li><li><a class="tocitem" href="../Components/substrate/">Substrate</a></li><li><a class="tocitem" href="../Components/bond_wire/">Bond Wire</a></li><li><a class="tocitem" href="../Components/bias_tee/">Bias Tee</a></li><li><a class="tocitem" href="../Components/dc_block/">DC Block</a></li><li><a class="tocitem" href="../Components/dc_feed/">DC Feed</a></li><li><a class="tocitem" href="../Components/attenuator/">Attenuator</a></li><li><a class="tocitem" href="../Components/amplifier/">Amplifier</a></li><li><a class="tocitem" href="../Components/opamp/">Operational Amplifier</a></li><li><a class="tocitem" href="../Components/phase_shifter/">Phase Shifter</a></li><li><a class="tocitem" href="../Components/circulator/">Circulator</a></li><li><a class="tocitem" href="../Components/isolator/">Isolator</a></li><li><a class="tocitem" href="../Components/coupler/">Coupler</a></li><li><a class="tocitem" href="../Components/hybrid/">Hybrid (180° or 90°)</a></li><li><a class="tocitem" href="../Components/gyrator/">Gyrator</a></li><li><a class="tocitem" href="../Components/spiral_inductor/">Spiral Inductor</a></li><li><a class="tocitem" href="../Components/circular_loop/">Circular Loop Inductor</a></li><li><a class="tocitem" href="../Components/transmission_line/">Transmission Line</a></li><li><a class="tocitem" href="../Components/coaxial_line/">Coaxial Line</a></li><li><a class="tocitem" href="../Components/ideal_transformer/">Ideal Transformer</a></li><li><a class="tocitem" href="../Components/mutual_inductor/">Mutual Inductor</a></li><li><a class="tocitem" href="../Components/spfile/">S-Parameter File</a></li><li><a class="tocitem" href="../Components/microstrip_line/">Microstrip Line</a></li><li><a class="tocitem" href="../Components/microstrip_gap/">Microstrip Gap</a></li><li><a class="tocitem" href="../Components/microstrip_step/">Microstrip Step</a></li><li><a class="tocitem" href="../Components/microstrip_corner/">Microstrip Corner</a></li><li><a class="tocitem" href="../Components/microstrip_coupled/">Microstrip Coupled Lines</a></li><li><a class="tocitem" href="../Components/microstrip_cross/">Microstrip Cross Junction</a></li><li><a class="tocitem" href="../Components/microstrip_tee/">Microstrip Tee Junction</a></li><li><a class="tocitem" href="../Components/microstrip_open/">Microstrip Open End</a></li><li><a class="tocitem" href="../Components/microstrip_via/">Microstrip Via</a></li><li><a class="tocitem" href="../Components/microstrip_radial_stub/">Microstrip Radial Stub</a></li><li><a class="tocitem" href="../Components/microstrip_mitered_bend/">Microstrip Mitered Bend</a></li><li><a class="tocitem" href="../Components/microstrip_lange/">Microstrip Lange Coupler</a></li><li><a class="tocitem" href="../Components/voltage_probe/">Voltage Probe</a></li><li><a class="tocitem" href="../Components/current_probe/">Current Probe</a></li><li><a class="tocitem" href="../Components/power_probe/">Power Probe</a></li></ul></li><li><span class="tocitem">Devices</span><ul><li><a class="tocitem" href="../Devices/diode/">Diode</a></li><li><a class="tocitem" href="../Devices/tunnel_diode/">Tunnel Diode</a></li><li><a class="tocitem" href="../Devices/jfet/">JFET</a></li><li><a class="tocitem" href="../Devices/diac/">DIAC</a></li><li><a class="tocitem" href="../Devices/mosfet/">MOSFET</a></li><li><a class="tocitem" href="../Devices/thyristor/">Thyristor (SCR)</a></li><li><a class="tocitem" href="../Devices/triac/">Triac</a></li><li><a class="tocitem" href="../Devices/bjt/">BJT (Bipolar Junction Transistor)</a></li><li><a class="tocitem" href="../Devices/equation_defined/">Equation Defined Device (EDD)</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../Examples/lowpass_filter/">LC Lowpass Filter</a></li><li><a class="tocitem" href="../Examples/dc_divider/">DC Analysis - Resistor Divider</a></li><li><a class="tocitem" href="../Examples/ac_divider/">AC Analysis - Capacitor Divider</a></li><li><a class="tocitem" href="../Examples/pin_current/">Pin Current Example</a></li></ul></li><li class="is-active"><a class="tocitem" href>API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ErikBuer/CircuitSim.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ErikBuer/CircuitSim.jl/blob/master/docs/src/api_reference.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><article><details class="docstring" open="true"><summary id="CircuitSim.ACAnalysis"><a class="docstring-binding" href="#CircuitSim.ACAnalysis"><code>CircuitSim.ACAnalysis</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ACAnalysis(start, stop, points; type=LOGARITHMIC, name=&quot;AC1&quot;)</code></pre><p>AC small-signal frequency sweep analysis.</p><p>Computes the small-signal AC response over a frequency range.</p><p><strong>Parameters</strong></p><ul><li><code>start::Real</code>: Start frequency in Hz</li><li><code>stop::Real</code>: Stop frequency in Hz</li><li><code>points::Int</code>: Number of frequency points</li><li><code>sweep_type::SweepType</code>: Type of frequency sweep (LINEAR or LOGARITHMIC, default: LOGARITHMIC)</li><li><code>name::String</code>: Analysis name (default: &quot;AC1&quot;)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Logarithmic sweep from 1Hz to 1MHz with 101 points
analysis = ACAnalysis(1.0, 1e6, 101)

# Linear sweep
analysis = ACAnalysis(100.0, 10e3, 100, sweep_type=LINEAR)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/analysis/ac_analysis.jl#L1-L25">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.ACCurrentSource"><a class="docstring-binding" href="#CircuitSim.ACCurrentSource"><code>CircuitSim.ACCurrentSource</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ACCurrentSource &lt;: AbstractACCurrentSource</code></pre><p>AC current source with two terminals. Current flows from nminus to nplus (into nplus).</p><p>For AC analysis, provides a sinusoidal current source.</p><ul><li><code>dc</code>: DC offset (default 0)</li><li><code>ac_mag</code>: AC magnitude for small-signal analysis  </li><li><code>ac_phase</code>: AC phase in degrees (default 0)</li><li><code>freq</code>: Frequency in Hz (for transient analysis)</li></ul><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>nplus::Int</code>: Positive terminal node number</li><li><code>nminus::Int</code>: Negative terminal node number</li><li><code>dc::Real</code>: DC offset current</li><li><code>ac_mag::Real</code>: AC magnitude in Amperes</li><li><code>ac_phase::Real</code>: AC phase in degrees</li><li><code>freq::Real</code>: Frequency in Hz</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># 1mA AC source at 1kHz
I1 = ACCurrentSource(&quot;I1&quot;, 0.001, freq=1e3)

# 10mA AC with 5mA DC offset
I2 = ACCurrentSource(&quot;I2&quot;, 0.01, dc=0.005, freq=50.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/sources/ac_current_source.jl#L1-L32">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.ACPowerSource"><a class="docstring-binding" href="#CircuitSim.ACPowerSource"><code>CircuitSim.ACPowerSource</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>AC Power Source component for S-parameter and frequency-domain analysis.</p><p>This is a generic power source with specified impedance, used as a port for S-parameter, AC, and harmonic balance analyses. In Qucsator netlists, this becomes a &quot;Pac&quot; component.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/sources/ac_power_source.jl#L1-L7">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.ACResult"><a class="docstring-binding" href="#CircuitSim.ACResult"><code>CircuitSim.ACResult</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ACResult</code></pre><p>AC analysis results (frequency sweep).</p><p><strong>Fields</strong></p><ul><li><code>frequencies_Hz::Vector{Float64}</code>: Frequency points</li><li><code>voltages::Dict{String,Vector{ComplexF64}}</code>: Node voltages vs frequency</li><li><code>currents::Dict{String,Vector{ComplexF64}}</code>: Branch currents vs frequency</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/parser/qucs_dataset.jl#L34-L44">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.ACVoltageSource"><a class="docstring-binding" href="#CircuitSim.ACVoltageSource"><code>CircuitSim.ACVoltageSource</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ACVoltageSource &lt;: AbstractACVoltageSource</code></pre><p>AC voltage source with two terminals.</p><p>For AC analysis, provides a sinusoidal voltage source.</p><ul><li><code>dc</code>: DC offset (default 0)</li><li><code>ac_mag</code>: AC magnitude for small-signal analysis</li><li><code>ac_phase</code>: AC phase in degrees (default 0)</li><li><code>freq</code>: Frequency in Hz (for transient analysis)</li></ul><p>Note: For AC analysis (.AC), only ac<em>mag and ac</em>phase are used. For transient analysis, all parameters define a sinusoid:  V(t) = dc + ac<em>mag * sin(2π<em>freq</em>t + ac</em>phase)</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>nplus::Int</code>: Positive terminal node number</li><li><code>nminus::Int</code>: Negative terminal node number</li><li><code>dc::Real</code>: DC offset voltage</li><li><code>ac_mag::Real</code>: AC magnitude in Volts</li><li><code>ac_phase::Real</code>: AC phase in degrees</li><li><code>freq::Real</code>: Frequency in Hz</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># 1V AC source at 1kHz
V1 = ACVoltageSource(&quot;V1&quot;, 1.0, freq=1e3)

# 5V AC with 2V DC offset
V2 = ACVoltageSource(&quot;V2&quot;, 5.0, dc=2.0, freq=1e6)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/sources/ac_voltage_source.jl#L1-L35">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.AbstractAnalysis"><a class="docstring-binding" href="#CircuitSim.AbstractAnalysis"><code>CircuitSim.AbstractAnalysis</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractAnalysis</code></pre><p>Abstract base type for all circuit analyses.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/analysis/analysis_types.jl#L1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.AbstractSweepAnalysis"><a class="docstring-binding" href="#CircuitSim.AbstractSweepAnalysis"><code>CircuitSim.AbstractSweepAnalysis</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractSweepAnalysis &lt;: AbstractAnalysis</code></pre><p>Abstract type for sweep-based analyses (AC, SP, parameter sweeps).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/analysis/analysis_types.jl#L8-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.Amplifier"><a class="docstring-binding" href="#CircuitSim.Amplifier"><code>CircuitSim.Amplifier</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Amplifier &lt;: AbstractPowerAmplifier</code></pre><p>RF/microwave amplifier with gain and noise figure.</p><p>This is a simplified amplifier model suitable for system-level simulations.</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>input::Int</code>: Input terminal node number</li><li><code>output::Int</code>: Output terminal node number</li><li><code>gain::Real</code>: Linear voltage gain. For 20 dB gain, use gain=10.0</li><li><code>nf::Real</code>: Noise figure (linear). For 3 dB NF, use nf=2.0. Default: 1.0 (noiseless)</li><li><code>z_in::Real</code>: Input impedance in Ohms (default: 50)</li><li><code>z_out::Real</code>: Output impedance in Ohms (default: 50)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/components/amplifier.jl#L1-L18">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.Attenuator"><a class="docstring-binding" href="#CircuitSim.Attenuator"><code>CircuitSim.Attenuator</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Attenuator &lt;: AbstractAttenuator</code></pre><p>RF attenuator for signal level control.</p><p>An attenuator reduces signal power by a specified amount while maintaining impedance matching.</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>n1::Int</code>: Input terminal node number</li><li><code>n2::Int</code>: Output terminal node number</li><li><code>attenuation::Real</code>: Attenuation in linear scale</li><li><code>z0::Real</code>: Reference impedance in Ohms (default: 50)</li><li><code>temp::Real</code>: Temperature in Celsius (default: 26.85)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/components/attenuator.jl#L1-L18">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.BiasTee"><a class="docstring-binding" href="#CircuitSim.BiasTee"><code>CircuitSim.BiasTee</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">BiasTee &lt;: AbstractBiasTee</code></pre><p>Bias tee for combining DC bias and RF signals.</p><p>A bias tee has three ports:</p><ul><li>RF port: AC coupled (passes RF, blocks DC)</li><li>DC port: DC coupled (passes DC, blocks RF) </li><li>Combined port: Both DC and RF</li></ul><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>n_rf::Int</code>: RF input port node number</li><li><code>n_dc::Int</code>: DC input port node number</li><li><code>n_out::Int</code>: Combined output port node number</li><li><code>c_block::Real</code>: DC blocking capacitance (default: 1 μF)</li><li><code>l_choke::Real</code>: RF choke inductance (default: 1 mH)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using CircuitSim
# Standard bias tee
BT1 = BiasTee(&quot;BT1&quot;)

# Custom component values
BT2 = BiasTee(&quot;BT2&quot;, c_block=10e-6, l_choke=10e-3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/components/bias_tee.jl#L1-L30">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.BondWire"><a class="docstring-binding" href="#CircuitSim.BondWire"><code>CircuitSim.BondWire</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">BondWire &lt;: AbstractBondWire</code></pre><p>A bond wire connection for chip interconnects.</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>n1::Int</code>: Node 1 (input)</li><li><code>n2::Int</code>: Node 2 (output)</li><li><code>l::Real</code>: Wire length (m)</li><li><code>d::Real</code>: Wire diameter (m)</li><li><code>h::Real</code>: Wire height above substrate (m)</li><li><code>rho::Real</code>: Resistivity relative to copper</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">wire = BondWire(&quot;BW1&quot;, l=1e-3, d=25e-6, h=0.3e-3)</code></pre><p><strong>Qucs Format</strong></p><p><code>BONDWIRE:Name Node1 Node2 L=&quot;length&quot; D=&quot;diameter&quot; H=&quot;height&quot; rho=&quot;resistivity&quot;</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/components/bond_wire.jl#L1-L25">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.Capacitor"><a class="docstring-binding" href="#CircuitSim.Capacitor"><code>CircuitSim.Capacitor</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Capacitor &lt;: AbstractCapacitor</code></pre><p>Ideal capacitor with two terminals.</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>n1::Int</code>: First terminal node number (assigned during circuit analysis)</li><li><code>n2::Int</code>: Second terminal node number (assigned during circuit analysis)</li><li><code>capacitance::Real</code>: Capacitance in Farads</li><li><code>initial_voltage::Real</code>: Initial voltage across the capacitor (default: 0.0)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">C1 = Capacitor(&quot;C1&quot;, capacitance=100e-9)  # 100nF capacitor
C2 = Capacitor(&quot;C2&quot;, capacitance=10e-6, initial_voltage=5.0)  # 10µF capacitor with 5V initial voltage</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/components/capacitor.jl#L1-L20">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.CapacitorQ"><a class="docstring-binding" href="#CircuitSim.CapacitorQ"><code>CircuitSim.CapacitorQ</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CapacitorQ &lt;: AbstractCapacitor</code></pre><p>Capacitor with quality factor for RF simulations.</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>n1::Int</code>: First terminal node number</li><li><code>n2::Int</code>: Second terminal node number</li><li><code>value::Real</code>: Capacitance in Farads</li><li><code>q::Real</code>: Quality factor (Q) at the specified frequency</li><li><code>freq::Real</code>: Frequency in Hz where Q is specified (default: 1 GHz)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using CircuitSim
C1 = CapacitorQ(&quot;C1&quot;, 10e-12, 50.0)  # 10pF capacitor with Q=50
C2 = CapacitorQ(&quot;C2&quot;, 100e-12, 100.0, freq=2.4e9)  # 100pF, Q=100 at 2.4 GHz</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/components/capacitor_q.jl#L1-L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.Circuit"><a class="docstring-binding" href="#CircuitSim.Circuit"><code>CircuitSim.Circuit</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Circuit representation: collection of components and connections</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/circuit.jl#L1-L3">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.CircularLoop"><a class="docstring-binding" href="#CircuitSim.CircularLoop"><code>CircuitSim.CircularLoop</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CircularLoop &lt;: AbstractCircularLoop</code></pre><p>A single-turn circular loop inductor.</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>n1::Int</code>: Node 1</li><li><code>n2::Int</code>: Node 2</li><li><code>r::Real</code>: Loop radius (m)</li><li><code>w::Real</code>: Wire/trace width (m)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">loop = CircularLoop(&quot;CL1&quot;, r=5e-3, w=0.5e-3)</code></pre><p><strong>Qucs Format</strong></p><p>Approximated using standard inductor with calculated value</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/components/circular_loop.jl#L1-L23">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.Circulator"><a class="docstring-binding" href="#CircuitSim.Circulator"><code>CircuitSim.Circulator</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Circulator &lt;: AbstractCirculator</code></pre><p>3-port RF circulator.</p><p>A circulator routes signals in one direction: port 1→2, 2→3, 3→1. Commonly used for isolating transmitter and receiver sharing an antenna.</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>n1::Int</code>: Port 1 node number</li><li><code>n2::Int</code>: Port 2 node number</li><li><code>n3::Int</code>: Port 3 node number</li><li><code>insertion_loss::Real</code>: Loss through forward path (dB) (default: 0.5)</li><li><code>isolation::Real</code>: Isolation to reverse path (dB) (default: 20)</li><li><code>z0::Real</code>: Reference impedance in Ohms (default: 50)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using CircuitSim
# Standard circulator
CIRC1 = Circulator(&quot;CIRC1&quot;)

# Custom circulator with better isolation
CIRC2 = Circulator(&quot;CIRC2&quot;, isolation=30.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/components/circulator.jl#L1-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.CoaxialLine"><a class="docstring-binding" href="#CircuitSim.CoaxialLine"><code>CircuitSim.CoaxialLine</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CoaxialLine &lt;: AbstractComponent</code></pre><p>Coaxial transmission line with physical parameters.</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>er::Float64</code>: Relative permittivity (default: 2.3)</li><li><code>mur::Float64</code>: Relative permeability (default: 1.0)</li><li><code>length_m::Float64</code>: Physical length in meters</li><li><code>d_mm::Float64</code>: Inner conductor diameter in mm</li><li><code>d_outer_mm::Float64</code>: Outer conductor diameter in mm</li><li><code>n1::Int</code>: Input port positive node</li><li><code>n2::Int</code>: Input port negative node</li><li><code>n3::Int</code>: Output port positive node</li><li><code>n4::Int</code>: Output port negative node</li></ul><p><strong>Pins</strong></p><ul><li><code>:n1</code>, <code>:n2</code>: Input port</li><li><code>:n3</code>, <code>:n4</code>: Output port</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; coax = CoaxialLine(&quot;COAX1&quot;, er=2.3, length_m=0.1, d_mm=0.5, d_outer_mm=3.0)
CoaxialLine(&quot;COAX1&quot;, 2.3, 1.0, 0.1, 0.5, 3.0, 0.0004, 2.2e-8, 0, 0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/components/coaxial_line.jl#L1-L30">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.Coupler"><a class="docstring-binding" href="#CircuitSim.Coupler"><code>CircuitSim.Coupler</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Coupler &lt;: AbstractCoupler</code></pre><p>Directional coupler (4-port device).</p><p>A directional coupler splits power with specified coupling factor. Ports: 1=input, 2=through, 3=coupled, 4=isolated</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>n1::Int</code>: Port 1 (input) node number</li><li><code>n2::Int</code>: Port 2 (through) node number</li><li><code>n3::Int</code>: Port 3 (coupled) node number</li><li><code>n4::Int</code>: Port 4 (isolated) node number</li><li><code>coupling::Real</code>: Coupling factor in dB (e.g., 3 for 3dB coupler, 10 for 10dB coupler)</li><li><code>isolation::Real</code>: Isolation in dB (default: 20)</li><li><code>insertion_loss::Real</code>: Insertion loss (through path) in dB (default: 0.5)</li><li><code>z0::Real</code>: Reference impedance in Ohms (default: 50)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using CircuitSim
# 3 dB (50/50) directional coupler
DC1 = Coupler(&quot;DC1&quot;, 3.0)

# 10 dB directional coupler (10% coupling)
DC2 = Coupler(&quot;DC2&quot;, 10.0)

# 20 dB directional coupler with high isolation
DC3 = Coupler(&quot;DC3&quot;, 20.0, isolation=30.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/components/coupler.jl#L1-L34">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.CurrentControlledCurrentSource"><a class="docstring-binding" href="#CircuitSim.CurrentControlledCurrentSource"><code>CircuitSim.CurrentControlledCurrentSource</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CurrentControlledCurrentSource(name::String; g::Real=1.0, t::Real=0.0)</code></pre><p>Create a current-controlled current source with 4-port configuration.</p><p><strong>Arguments</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>g::Real</code>: Current gain (dimensionless) (default 1.0)</li><li><code>t::Real</code>: Time delay in seconds (default 0.0)</li></ul><p><strong>Fields</strong></p><ul><li><code>n1::Int</code>: Positive input node (where current is sensed)</li><li><code>n2::Int</code>: Negative input node (where current is sensed)</li><li><code>n3::Int</code>: Positive output node</li><li><code>n4::Int</code>: Negative output node</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/sources/current_controlled_current_source.jl#L1-L18">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.CurrentControlledVoltageSource"><a class="docstring-binding" href="#CircuitSim.CurrentControlledVoltageSource"><code>CircuitSim.CurrentControlledVoltageSource</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Current-Controlled Voltage Source (CCVS).</p><p>A voltage source whose output voltage is controlled by the current through another element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/sources/current_controlled_voltage_source.jl#L1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.CurrentCurrentNoiseSource"><a class="docstring-binding" href="#CircuitSim.CurrentCurrentNoiseSource"><code>CircuitSim.CurrentCurrentNoiseSource</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CurrentCurrentNoiseSource(name::String; i1::Real=1e-6, i2::Real=1e-6, c_corr::Real=0.0, a::Real=0.0, c::Real=1.0, e::Real=0.0)</code></pre><p>Create correlated current-current noise sources with 4-port configuration.</p><p><strong>Arguments</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>i1::Real</code>: RMS current of first source in A (default 1e-6)</li><li><code>i2::Real</code>: RMS current of second source in A (default 1e-6)</li><li><code>c_corr::Real</code>: Correlation coefficient -1 to 1 (default 0.0)</li><li><code>a::Real</code>: Flicker noise exponent (default 0.0)</li><li><code>c::Real</code>: Flicker noise coefficient (default 1.0)</li><li><code>e::Real</code>: Flicker noise frequency exponent (default 0.0)</li></ul><p><strong>Fields</strong></p><ul><li><code>i1plus::Int</code>: Positive node of first current source</li><li><code>i1minus::Int</code>: Negative node of first current source</li><li><code>i2plus::Int</code>: Positive node of second current source</li><li><code>i2minus::Int</code>: Negative node of second current source</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/sources/current_current_noise_source.jl#L1-L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.CurrentExponentialSource"><a class="docstring-binding" href="#CircuitSim.CurrentExponentialSource"><code>CircuitSim.CurrentExponentialSource</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CurrentExponentialSource &lt;: AbstractCurrentSource</code></pre><p>Exponential rise/fall current source for transient analysis.</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>n1::Int</code>: Positive terminal node number</li><li><code>n2::Int</code>: Negative terminal node number</li><li><code>i1::Real</code>: Initial current level (A)</li><li><code>i2::Real</code>: Final current level (A)</li><li><code>t1::Real</code>: Rise delay time (s)</li><li><code>t2::Real</code>: Fall delay time (s)</li><li><code>tr::Real</code>: Rise time constant (s, optional, default 1ns)</li><li><code>tf::Real</code>: Fall time constant (s, optional, default 1ns)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">isrc = CurrentExponentialSource(&quot;Iexp1&quot;, i1=0.0, i2=10e-3, t1=1e-9, t2=10e-9)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/sources/current_exponential_source.jl#L1-L23">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.CurrentNoiseSource"><a class="docstring-binding" href="#CircuitSim.CurrentNoiseSource"><code>CircuitSim.CurrentNoiseSource</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CurrentNoiseSource &lt;: AbstractCurrentSource</code></pre><p>Current noise source for noise analysis with frequency-dependent PSD.</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>n1::Int</code>: Positive terminal node number</li><li><code>n2::Int</code>: Negative terminal node number</li><li><code>i::Real</code>: Noise power spectral density (A²/Hz)</li><li><code>a::Real</code>: Frequency offset parameter (optional, default 0)</li><li><code>c::Real</code>: Frequency coefficient (optional, default 1)</li><li><code>e::Real</code>: Frequency exponent (optional, default 0)</li></ul><p>Noise PSD formula: PSD(f) = i / (a + c * f^e)</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">isrc = CurrentNoiseSource(&quot;Inoise1&quot;, i=1e-12, e=0)  # White noise</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/sources/current_noise_source.jl#L1-L21">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.CurrentProbe"><a class="docstring-binding" href="#CircuitSim.CurrentProbe"><code>CircuitSim.CurrentProbe</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Current probe for measuring current in AC, DC, and transient analyses.</p><p>The probe is inserted in series with a circuit element and measures current. It acts as a short circuit (zero impedance).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/probes/current_probe.jl#L1-L6">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.CurrentPulseSource"><a class="docstring-binding" href="#CircuitSim.CurrentPulseSource"><code>CircuitSim.CurrentPulseSource</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CurrentPulseSource &lt;: AbstractSource</code></pre><p>Current source with pulse waveform for transient analysis.</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>n1::Int</code>: Positive terminal node number</li><li><code>n2::Int</code>: Negative terminal node number</li><li><code>i1::Real</code>: Initial current level (A)</li><li><code>i2::Real</code>: Pulsed current level (A)</li><li><code>t1::Real</code>: Start time of pulse (s)</li><li><code>t2::Real</code>: End time of pulse (s)</li><li><code>tr::Real</code>: Rise time (s, optional, default 1ns)</li><li><code>tf::Real</code>: Fall time (s, optional, default 1ns)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">isrc = CurrentPulseSource(&quot;Ipulse1&quot;, i1=0.0, i2=10e-3, t1=1e-9, t2=10e-9)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/sources/current_pulse_source.jl#L1-L23">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.CurrentRectangularSource"><a class="docstring-binding" href="#CircuitSim.CurrentRectangularSource"><code>CircuitSim.CurrentRectangularSource</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CurrentRectangularSource &lt;: AbstractCurrentSource</code></pre><p>Periodic rectangular pulse current source for transient analysis.</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>n1::Int</code>: Positive terminal node number</li><li><code>n2::Int</code>: Negative terminal node number</li><li><code>i::Real</code>: Pulse current level (A)</li><li><code>th::Real</code>: High time duration (s)</li><li><code>tl::Real</code>: Low time duration (s)</li><li><code>tr::Real</code>: Rise time (s, optional, default 1ns)</li><li><code>tf::Real</code>: Fall time (s, optional, default 1ns)</li><li><code>td::Real</code>: Delay time (s, optional, default 0)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">isrc = CurrentRectangularSource(&quot;Irect1&quot;, i=10e-3, th=1e-6, tl=1e-6)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/sources/current_rectangular_source.jl#L1-L23">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.CurrentVoltageNoiseSource"><a class="docstring-binding" href="#CircuitSim.CurrentVoltageNoiseSource"><code>CircuitSim.CurrentVoltageNoiseSource</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CurrentVoltageNoiseSource(name::String; i1::Real=1e-6, v2::Real=1e-6, c_corr::Real=0.0, a::Real=0.0, c::Real=1.0, e::Real=0.0)</code></pre><p>Create correlated current-voltage noise sources with 4-port configuration.</p><p><strong>Arguments</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>i1::Real</code>: RMS current in A (default 1e-6)</li><li><code>v2::Real</code>: RMS voltage in V (default 1e-6)</li><li><code>c_corr::Real</code>: Correlation coefficient -1 to 1 (default 0.0)</li><li><code>a::Real</code>: Flicker noise exponent (default 0.0)</li><li><code>c::Real</code>: Flicker noise coefficient (default 1.0)</li><li><code>e::Real</code>: Flicker noise frequency exponent (default 0.0)</li></ul><p><strong>Fields</strong></p><ul><li><code>i1plus::Int</code>: Positive node of current source</li><li><code>i1minus::Int</code>: Negative node of current source</li><li><code>v2plus::Int</code>: Positive node of voltage source</li><li><code>v2minus::Int</code>: Negative node of voltage source</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/sources/current_voltage_noise_source.jl#L1-L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.DCAnalysis"><a class="docstring-binding" href="#CircuitSim.DCAnalysis"><code>CircuitSim.DCAnalysis</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DCAnalysis(; save_ops=true, temp=26.85, save_all=false)</code></pre><p>DC operating point analysis.</p><p>Computes the DC operating point of the circuit.</p><p><strong>Parameters</strong></p><ul><li><code>save_ops::Bool</code>: Save operating points of nonlinear devices (default: true)</li><li><code>temp::Real</code>: Simulation temperature in °C (default: 26.85)</li><li><code>save_all::Bool</code>: Save all node voltages and branch currents (default: false)</li><li><code>name::String</code>: Analysis name (default: &quot;DC1&quot;)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">analysis = DCAnalysis()
result = simulate_qucsator(circuit, analysis)

# With custom temperature
analysis = DCAnalysis(temp=85.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/analysis/dc_analysis.jl#L1-L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.DCBlock"><a class="docstring-binding" href="#CircuitSim.DCBlock"><code>CircuitSim.DCBlock</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DCBlock &lt;: AbstractDCBlock</code></pre><p>DC blocking capacitor for RF applications.</p><p>This is essentially a large capacitor that passes AC signals while blocking DC. Typically used to isolate DC bias points between stages.</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>n1::Int</code>: First terminal node number</li><li><code>n2::Int</code>: Second terminal node number</li><li><code>value::Real</code>: Capacitance in Farads (default: 1 μF for near-ideal blocking)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using CircuitSim
# Default DC block (1 μF)
DCB1 = DCBlock(&quot;DCB1&quot;)

# Custom capacitance
DCB2 = DCBlock(&quot;DCB2&quot;, 10e-6)  # 10 μF</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/components/dc_block.jl#L1-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.DCCurrentSource"><a class="docstring-binding" href="#CircuitSim.DCCurrentSource"><code>CircuitSim.DCCurrentSource</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DCCurrentSource &lt;: AbstractDCCurrentSource</code></pre><p>DC current source with two terminals. Current flows from nminus to nplus (into nplus).</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>nplus::Int</code>: Positive terminal node number</li><li><code>nminus::Int</code>: Negative terminal node number</li><li><code>dc::Real</code>: DC current in Amperes</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">I1 = DCCurrentSource(&quot;I1&quot;, 0.001)  # 1mA DC source</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/sources/dc_current_source.jl#L1-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.DCFeed"><a class="docstring-binding" href="#CircuitSim.DCFeed"><code>CircuitSim.DCFeed</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DCFeed &lt;: AbstractDCFeed</code></pre><p>DC feed (RF choke) for providing DC bias while blocking RF.</p><p>This component passes DC current while presenting high impedance to RF signals. Typically implemented as a large inductor.</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>n1::Int</code>: First terminal node number</li><li><code>n2::Int</code>: Second terminal node number</li><li><code>value::Real</code>: Inductance in Henries (default: 1 mH for good RF blocking)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using CircuitSim
# Default DC feed (1 mH)
DCF1 = DCFeed(&quot;DCF1&quot;)

# Custom inductance
DCF2 = DCFeed(&quot;DCF2&quot;, 10e-3)  # 10 mH</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/components/dc_feed.jl#L1-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.DCResult"><a class="docstring-binding" href="#CircuitSim.DCResult"><code>CircuitSim.DCResult</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DCResult</code></pre><p>DC operating point results.</p><p><strong>Fields</strong></p><ul><li><code>voltages::Dict{String,Float64}</code>: Node voltages (node_name =&gt; voltage)</li><li><code>currents::Dict{String,Float64}</code>: Branch currents (component_name =&gt; current)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/parser/qucs_dataset.jl#L19-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.DCVoltageSource"><a class="docstring-binding" href="#CircuitSim.DCVoltageSource"><code>CircuitSim.DCVoltageSource</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DCVoltageSource &lt;: AbstractDCVoltageSource</code></pre><p>DC voltage source with two terminals.</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>nplus::Int</code>: Positive terminal node number</li><li><code>nminus::Int</code>: Negative terminal node number</li><li><code>dc::Real</code>: DC voltage in Volts</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">V1 = DCVoltageSource(&quot;V1&quot;, 12.0)  # 12V DC source</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/sources/dc_voltage_source.jl#L1-L18">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.DataVector"><a class="docstring-binding" href="#CircuitSim.DataVector"><code>CircuitSim.DataVector</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DataVector</code></pre><p>Represents a data vector from simulation output.</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Vector name</li><li><code>values::Vector{ComplexF64}</code>: Data values</li><li><code>dependencies::Vector{String}</code>: Names of independent variables this depends on</li><li><code>is_independent::Bool</code>: Whether this is an independent variable</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/parser/qucs_dataset.jl#L95-L106">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.FileCurrentSource"><a class="docstring-binding" href="#CircuitSim.FileCurrentSource"><code>CircuitSim.FileCurrentSource</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">FileCurrentSource &lt;: AbstractSource</code></pre><p>File-based current source for transient analysis.</p><p>This component can operate in two modes:</p><ol><li><strong>File mode</strong>: Reads current vs. time data from an external file</li><li><strong>Vector mode</strong>: Accepts Julia vectors and automatically creates temporary file</li></ol><p>The data consists of time-current pairs that are interpolated during simulation.</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>nplus::Int</code>: Positive terminal node number (current flows from nplus to nminus)</li><li><code>nminus::Int</code>: Negative terminal node number</li><li><code>file::Union{String,Nothing}</code>: Path to data file (nothing for vector mode)</li><li><code>time_vector::Union{AbstractVector,Nothing}</code>: Time values for vector mode</li><li><code>current_vector::Union{AbstractVector,Nothing}</code>: Current values for vector mode</li><li><code>interpolator::String</code>: Interpolation method (&quot;linear&quot;, &quot;cubic&quot;, or &quot;hold&quot;)</li><li><code>repeat::Bool</code>: Whether to repeat the waveform</li><li><code>gain::Real</code>: Gain factor (multiplier for current values)</li><li><code>delay::Real</code>: Time delay in seconds</li><li><code>format::Symbol</code>: File format (:csv or :qucs_dataset, default :csv)</li></ul><p><strong>Supported File Formats</strong></p><p><strong>CSV Format (default, recommended)</strong></p><p>Two columns: time, current (comma or semicolon separated) Optional header row with column names</p><p>Example:</p><pre><code class="nohighlight hljs">time,current
0.0,0.0
1e-9,0.001
2e-9,0.001</code></pre><p><strong>Qucs Dataset Format</strong></p><p>Native qucsator format with indep/dep blocks</p><p>Example:</p><pre><code class="nohighlight hljs">&lt;Qucs Dataset 1.0.0&gt;
&lt;indep time 3&gt;
  0.0
  1e-9
  2e-9
&lt;/indep&gt;
&lt;dep I1 3&gt;
  0.0
  0.001
  0.001
&lt;/dep&gt;</code></pre><p><strong>Example</strong></p><pre><code class="language-julia hljs">using CircuitSim

# Vector mode - creates a temporary csv file and passes to qucsator.
time = [0.0, 1e-9, 2e-9, 3e-9, 4e-9]
current = [0.0, 0.001, 0.001, 0.0, 0.0]
I1 = FileCurrentSource(&quot;I1&quot;, time, current)

# Vector mode with Qucs Dataset format
I2 = FileCurrentSource(&quot;I2&quot;, time, current, format=:qucs_dataset)

# File mode - read from existing file
I3 = FileCurrentSource(&quot;I3&quot;, &quot;my_current.csv&quot;)

# With cubic interpolation and repeating waveform
I4 = FileCurrentSource(&quot;I4&quot;, time, current, interpolator=&quot;cubic&quot;, repeat=true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/sources/file_current_source.jl#L1-L77">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.FileVoltageSource"><a class="docstring-binding" href="#CircuitSim.FileVoltageSource"><code>CircuitSim.FileVoltageSource</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">FileVoltageSource &lt;: AbstractSource</code></pre><p>File-based voltage source for transient analysis.</p><p>This component can operate in two modes:</p><ol><li><strong>File mode</strong>: Reads voltage vs. time data from an external file</li><li><strong>Vector mode</strong>: Accepts Julia vectors and automatically creates temporary file</li></ol><p>The data consists of time-voltage pairs that are interpolated during simulation.</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>nplus::Int</code>: Positive terminal node number  </li><li><code>nminus::Int</code>: Negative terminal node number</li><li><code>file::Union{String,Nothing}</code>: Path to data file (nothing for vector mode)</li><li><code>time_vector::Union{AbstractVector,Nothing}</code>: Time values for vector mode</li><li><code>voltage_vector::Union{AbstractVector,Nothing}</code>: Voltage values for vector mode</li><li><code>interpolator::String</code>: Interpolation method (&quot;linear&quot;, &quot;cubic&quot;, or &quot;hold&quot;)</li><li><code>repeat::Bool</code>: Whether to repeat the waveform</li><li><code>gain::Real</code>: Gain factor (multiplier for voltage values)</li><li><code>delay::Real</code>: Time delay in seconds</li><li><code>format::Symbol</code>: File format (:csv or :qucs_dataset, default :csv)</li></ul><p><strong>Supported File Formats</strong></p><p><strong>CSV Format (default, recommended)</strong></p><p>Two columns: time, voltage (comma or semicolon separated) Optional header row with column names</p><p>Example:</p><pre><code class="nohighlight hljs">time,voltage
0.0,0.0
1e-9,1.0
2e-9,0.5</code></pre><p><strong>Qucs Dataset Format</strong></p><p>Native qucsator format with indep/dep blocks</p><p>Example:</p><pre><code class="nohighlight hljs">&lt;Qucs Dataset 1.0.0&gt;
&lt;indep time 4&gt;
  0.0
  1e-9
  2e-9
  3e-9
&lt;/indep&gt;
&lt;dep V1 4&gt;
  0.0
  1.0
  0.5
  0.0
&lt;/dep&gt;</code></pre><p><strong>Example</strong></p><pre><code class="language-julia hljs">using CircuitSim

# Vector mode - creates a temporary csv file and passes to qucsator.
time = [0.0, 1e-9, 2e-9, 3e-9]
voltage = [0.0, 1.0, 1.0, 0.0]
V1 = FileVoltageSource(&quot;V1&quot;, time, voltage)

# Vector mode with Qucs Dataset format
V2 = FileVoltageSource(&quot;V2&quot;, time, voltage, format=:qucs_dataset)

# File mode - read from existing file
V3 = FileVoltageSource(&quot;V3&quot;, &quot;my_waveform.csv&quot;)

# With interpolation and gain
V4 = FileVoltageSource(&quot;V4&quot;, time, voltage, interpolator=&quot;cubic&quot;, gain=2.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/sources/file_voltage_source.jl#L1-L79">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.Ground"><a class="docstring-binding" href="#CircuitSim.Ground"><code>CircuitSim.Ground</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Ground &lt;: AbstractGround</code></pre><p>Ground reference node (single pin). Maps to node 0.</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>n::Int</code>: Terminal node number (always 0 for ground)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">GND = Ground(&quot;GND&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/components/ground.jl#L5-L20">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.Gyrator"><a class="docstring-binding" href="#CircuitSim.Gyrator"><code>CircuitSim.Gyrator</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Gyrator &lt;: AbstractComponent</code></pre><p>Gyrator converts impedance (e.g., capacitor ↔ inductor).</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>r::Float64</code>: Gyration resistance in Ω (default: 50.0)</li><li><code>zref::Float64</code>: Reference impedance in Ω (default: 50.0)</li><li><code>n1::Int</code>: Port 1 positive node</li><li><code>n2::Int</code>: Port 1 negative node</li><li><code>n3::Int</code>: Port 2 positive node</li><li><code>n4::Int</code>: Port 2 negative node</li></ul><p><strong>Pins</strong></p><ul><li><code>:n1</code>, <code>:n2</code>: Port 1</li><li><code>:n3</code>, <code>:n4</code>: Port 2</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; gyr = Gyrator(&quot;GYR1&quot;, r=100.0)
Gyrator(&quot;GYR1&quot;, 100.0, 50.0, 0, 0, 0, 0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/components/gyrator.jl#L1-L27">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.HarmonicBalanceAnalysis"><a class="docstring-binding" href="#CircuitSim.HarmonicBalanceAnalysis"><code>CircuitSim.HarmonicBalanceAnalysis</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">HarmonicBalanceAnalysis(frequency; harmonics=5, name=&quot;HB1&quot;)</code></pre><p>Harmonic balance analysis for steady-state analysis of nonlinear circuits with periodic excitation.</p><p><strong>Parameters</strong></p><ul><li><code>frequency::Real</code>: Fundamental frequency in Hz</li><li><code>harmonics::Int</code>: Number of harmonics to include (default: 5)</li><li><code>name::String</code>: Analysis name (default: &quot;HB1&quot;)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Harmonic balance at 1GHz with 7 harmonics
analysis = HarmonicBalanceAnalysis(1e9, harmonics=7)

# RF mixer analysis at 100MHz
analysis = HarmonicBalanceAnalysis(100e6, harmonics=11)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/analysis/harmonic_balance_analysis.jl#L1-L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.Hybrid"><a class="docstring-binding" href="#CircuitSim.Hybrid"><code>CircuitSim.Hybrid</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Hybrid &lt;: AbstractHybridCoupler</code></pre><p>Hybrid coupler (90° or 180° 3dB power splitter/combiner).</p><p>A hybrid coupler is a specialized 4-port device that splits power equally between two ports with a specific phase relationship.</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>n1::Int</code>: Port 1 (sum) node number</li><li><code>n2::Int</code>: Port 2 (difference/isolated) node number</li><li><code>n3::Int</code>: Port 3 (output 1) node number</li><li><code>n4::Int</code>: Port 4 (output 2) node number</li><li><code>phase::Real</code>: Phase difference in degrees (90 or 180) (default: 90)</li><li><code>insertion_loss::Real</code>: Insertion loss in dB (default: 0.5)</li><li><code>isolation::Real</code>: Isolation between ports in dB (default: 20)</li><li><code>z0::Real</code>: Reference impedance in Ohms (default: 50)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using CircuitSim
# 90 degree hybrid (quadrature hybrid)
HYB1 = Hybrid(&quot;HYB1&quot;)

# 180 degree hybrid (rat-race, magic-T)
HYB2 = Hybrid(&quot;HYB2&quot;, phase=180.0)

# Low-loss 90 degree hybrid
HYB3 = Hybrid(&quot;HYB3&quot;, insertion_loss=0.2, isolation=30.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/components/hybrid.jl#L1-L34">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.IdealTransformer"><a class="docstring-binding" href="#CircuitSim.IdealTransformer"><code>CircuitSim.IdealTransformer</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">IdealTransformer &lt;: AbstractComponent</code></pre><p>Ideal transformer with specified turns ratio.</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>t::Float64</code>: Turns ratio N2/N1 (default: 1.0)</li><li><code>n1::Int</code>: Primary winding positive node</li><li><code>n2::Int</code>: Primary winding negative node</li><li><code>n3::Int</code>: Secondary winding positive node</li><li><code>n4::Int</code>: Secondary winding negative node</li></ul><p><strong>Pins</strong></p><ul><li><code>:n1</code>, <code>:n2</code>: Primary winding</li><li><code>:n3</code>, <code>:n4</code>: Secondary winding</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; trafo = IdealTransformer(&quot;TR1&quot;, t=2.0)
IdealTransformer(&quot;TR1&quot;, 2.0, 0, 0, 0, 0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/components/ideal_transformer.jl#L1-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.Inductor"><a class="docstring-binding" href="#CircuitSim.Inductor"><code>CircuitSim.Inductor</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Inductor &lt;: AbstractInductor</code></pre><p>Ideal inductor with two terminals.</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>n1::Int</code>: First terminal node number (assigned during circuit analysis)</li><li><code>n2::Int</code>: Second terminal node number (assigned during circuit analysis)</li><li><code>value::Real</code>: Inductance in Henries</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">L1 = Inductor(&quot;L1&quot;, 10e-6)  # 10μH inductor</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/components/inductor.jl#L1-L18">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.InductorQ"><a class="docstring-binding" href="#CircuitSim.InductorQ"><code>CircuitSim.InductorQ</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">InductorQ &lt;: AbstractInductor</code></pre><p>Inductor with quality factor for RF simulations.</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>n1::Int</code>: First terminal node number</li><li><code>n2::Int</code>: Second terminal node number</li><li><code>value::Real</code>: Inductance in Henries</li><li><code>q::Real</code>: Quality factor (Q) at the specified frequency</li><li><code>freq::Real</code>: Frequency in Hz where Q is specified (default: 1 GHz)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using CircuitSim
L1 = InductorQ(&quot;L1&quot;, 10e-9, 30.0)  # 10nH inductor with Q=30
L2 = InductorQ(&quot;L2&quot;, 100e-9, 50.0, freq=2.4e9)  # 100nH, Q=50 at 2.4 GHz</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/components/inductor_q.jl#L1-L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.Isolator"><a class="docstring-binding" href="#CircuitSim.Isolator"><code>CircuitSim.Isolator</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Isolator &lt;: AbstractIsolator</code></pre><p>RF isolator (unidirectional component).</p><p>An isolator allows signals to pass in one direction (forward) while  blocking signals in the reverse direction. Commonly used to protect  sources from reflections.</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>n1::Int</code>: Input terminal node number</li><li><code>n2::Int</code>: Output terminal node number</li><li><code>forward_loss::Real</code>: Insertion loss in forward direction (dB) (default: 0.5)</li><li><code>reverse_loss::Real</code>: Isolation in reverse direction (dB) (default: 20)</li><li><code>z0::Real</code>: Reference impedance in Ohms (default: 50)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using CircuitSim
# Standard isolator: 0.5 dB forward loss, 20 dB isolation
ISO1 = Isolator(&quot;ISO1&quot;)

# Custom isolator: 1 dB forward loss, 30 dB isolation
ISO2 = Isolator(&quot;ISO2&quot;, forward_loss=1.0, reverse_loss=30.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/components/isolator.jl#L1-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.MicrostripCorner"><a class="docstring-binding" href="#CircuitSim.MicrostripCorner"><code>CircuitSim.MicrostripCorner</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MicrostripCorner &lt;: AbstractMicrostripCorner</code></pre><p>A 90° microstrip corner/bend.</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>n1::Int</code>: Node 1 (input)</li><li><code>n2::Int</code>: Node 2 (output)</li><li><code>substrate::Substrate</code>: Substrate definition reference</li><li><code>w::Real</code>: Line width (m)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">sub = Substrate(&quot;FR4&quot;, er=4.5, h=1.6e-3)
corner = MicrostripCorner(&quot;MC1&quot;, sub, w=3.0e-3)</code></pre><p><strong>Qucs Format</strong></p><p><code>MCORN:Name Node1 Node2 Subst=&quot;SubstName&quot; W=&quot;width&quot;</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/components/microstrip_corner.jl#L5-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.MicrostripCoupled"><a class="docstring-binding" href="#CircuitSim.MicrostripCoupled"><code>CircuitSim.MicrostripCoupled</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MicrostripCoupled &lt;: AbstractMicrostripCoupled</code></pre><p>A pair of microstrip coupled transmission lines (4-port).</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>n1::Int</code>: Node 1 (line 1 input)</li><li><code>n2::Int</code>: Node 2 (line 1 output)</li><li><code>n3::Int</code>: Node 3 (line 2 input)</li><li><code>n4::Int</code>: Node 4 (line 2 output)</li><li><code>substrate::Substrate</code>: Substrate definition reference</li><li><code>w::Real</code>: Line width (m)</li><li><code>l::Real</code>: Line length (m)</li><li><code>s::Real</code>: Line spacing (m)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">sub = Substrate(&quot;FR4&quot;, er=4.5, h=1.6e-3)
coupled = MicrostripCoupled(&quot;MCPL1&quot;, sub, w=1.0e-3, l=20e-3, s=0.2e-3)</code></pre><p><strong>Qucs Format</strong></p><p><code>MCOUPLED:Name Node1 Node2 Node3 Node4 Subst=&quot;SubstName&quot; W=&quot;width&quot; L=&quot;length&quot; S=&quot;spacing&quot;</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/components/microstrip_coupled.jl#L1-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.MicrostripCross"><a class="docstring-binding" href="#CircuitSim.MicrostripCross"><code>CircuitSim.MicrostripCross</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MicrostripCross &lt;: AbstractMicrostripCross</code></pre><p>A microstrip cross-junction (4-port).</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>n1::Int</code>: Node 1 (port 1)</li><li><code>n2::Int</code>: Node 2 (port 2)</li><li><code>n3::Int</code>: Node 3 (port 3)</li><li><code>n4::Int</code>: Node 4 (port 4)</li><li><code>substrate::Substrate</code>: Substrate definition reference</li><li><code>w1::Real</code>: Port 1 width (m)</li><li><code>w2::Real</code>: Port 2 width (m)</li><li><code>w3::Real</code>: Port 3 width (m)</li><li><code>w4::Real</code>: Port 4 width (m)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">sub = Substrate(&quot;FR4&quot;, er=4.5, h=1.6e-3)
cross = MicrostripCross(&quot;MX1&quot;, sub, w1=3.0e-3, w2=3.0e-3, w3=3.0e-3, w4=3.0e-3)</code></pre><p><strong>Qucs Format</strong></p><p><code>MCROSS:Name Node1 Node2 Node3 Node4 Subst=&quot;SubstName&quot; W1=&quot;w1&quot; W2=&quot;w2&quot; W3=&quot;w3&quot; W4=&quot;w4&quot;</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/components/microstrip_cross.jl#L5-L30">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.MicrostripGap"><a class="docstring-binding" href="#CircuitSim.MicrostripGap"><code>CircuitSim.MicrostripGap</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MicrostripGap &lt;: AbstractMicrostripGap</code></pre><p>A microstrip series gap discontinuity providing capacitive coupling.</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>n1::Int</code>: Node 1 (input)</li><li><code>n2::Int</code>: Node 2 (output)</li><li><code>substrate::Substrate</code>: Substrate definition reference</li><li><code>w1::Real</code>: Width at port 1 (m)</li><li><code>w2::Real</code>: Width at port 2 (m)</li><li><code>s::Real</code>: Gap spacing (m)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">sub = Substrate(&quot;FR4&quot;, er=4.5, h=1.6e-3)
gap = MicrostripGap(&quot;MG1&quot;, sub, w1=3.0e-3, w2=3.0e-3, s=0.2e-3)</code></pre><p><strong>Qucs Format</strong></p><p><code>MGAP:Name Node1 Node2 Subst=&quot;SubstName&quot; W1=&quot;width1&quot; W2=&quot;width2&quot; S=&quot;spacing&quot;</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/components/microstrip_gap.jl#L1-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.MicrostripLange"><a class="docstring-binding" href="#CircuitSim.MicrostripLange"><code>CircuitSim.MicrostripLange</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MicrostripLange &lt;: AbstractMicrostripLange</code></pre><p>A Lange coupler - an interdigitated microstrip directional coupler providing tight coupling.</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>n1::Int</code>: Node 1 (input)</li><li><code>n2::Int</code>: Node 2 (through)</li><li><code>n3::Int</code>: Node 3 (coupled)</li><li><code>n4::Int</code>: Node 4 (isolated)</li><li><code>substrate::Substrate</code>: Substrate definition reference</li><li><code>w::Real</code>: Finger width (m)</li><li><code>l::Real</code>: Finger length (m)</li><li><code>s::Real</code>: Finger spacing (m)</li><li><code>n::Int</code>: Number of fingers</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">sub = Substrate(&quot;RO4003C&quot;, er=3.55, h=0.508e-3)
lange = MicrostripLange(&quot;LC1&quot;, sub, w=0.15e-3, l=10e-3, s=0.1e-3, n=4)</code></pre><p><strong>Qucs Format</strong></p><p><code>MLANGE:Name Node1 Node2 Node3 Node4 Subst=&quot;SubstName&quot; W=&quot;width&quot; L=&quot;length&quot; S=&quot;spacing&quot; N=&quot;fingers&quot;</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/components/microstrip_lange.jl#L1-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.MicrostripLine"><a class="docstring-binding" href="#CircuitSim.MicrostripLine"><code>CircuitSim.MicrostripLine</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MicrostripLine &lt;: AbstractMicrostripLine</code></pre><p>A microstrip transmission line segment.</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>n1::Int</code>: Node 1 (input)</li><li><code>n2::Int</code>: Node 2 (output)</li><li><code>substrate::Substrate</code>: Substrate definition reference</li><li><code>w::Real</code>: Line width (m)</li><li><code>l::Real</code>: Line length (m)</li><li><code>model::String</code>: Optional SPICE model name</li><li><code>temp::Real</code>: Temperature (K)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">sub = Substrate(&quot;FR4&quot;, er=4.5, h=1.6e-3)
line = MicrostripLine(&quot;MS1&quot;, sub, w=3.0e-3, l=20e-3)</code></pre><p><strong>Qucs Format</strong></p><p><code>MLIN:Name Node1 Node2 Subst=&quot;SubstName&quot; W=&quot;width&quot; L=&quot;length&quot; Temp=&quot;temp&quot;</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/components/microstrip_line.jl#L1-L27">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.MicrostripMiteredBend"><a class="docstring-binding" href="#CircuitSim.MicrostripMiteredBend"><code>CircuitSim.MicrostripMiteredBend</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MicrostripMiteredBend &lt;: AbstractMicrostripMiteredBend</code></pre><p>A mitered microstrip 90° bend with corner cut for improved performance.</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>n1::Int</code>: Node 1 (input)</li><li><code>n2::Int</code>: Node 2 (output)</li><li><code>substrate::Substrate</code>: Substrate definition reference</li><li><code>w::Real</code>: Line width (m)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">sub = Substrate(&quot;FR4&quot;, er=4.5, h=1.6e-3)
bend = MicrostripMiteredBend(&quot;MB1&quot;, sub, w=3.0e-3)</code></pre><p><strong>Qucs Format</strong></p><p><code>MBEND:Name Node1 Node2 Subst=&quot;SubstName&quot; W=&quot;width&quot;</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/components/microstrip_mitered_bend.jl#L1-L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.MicrostripOpen"><a class="docstring-binding" href="#CircuitSim.MicrostripOpen"><code>CircuitSim.MicrostripOpen</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MicrostripOpen &lt;: AbstractMicrostripOpen</code></pre><p>A microstrip open-circuit termination with end-effect modeling.</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>n1::Int</code>: Node 1 (input)</li><li><code>substrate::Substrate</code>: Substrate definition reference</li><li><code>w::Real</code>: Line width (m)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">sub = Substrate(&quot;FR4&quot;, er=4.5, h=1.6e-3)
open_end = MicrostripOpen(&quot;MO1&quot;, sub, w=3.0e-3)</code></pre><p><strong>Qucs Format</strong></p><p><code>MOPEN:Name Node1 Subst=&quot;SubstName&quot; W=&quot;width&quot;</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/components/microstrip_open.jl#L1-L23">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.MicrostripRadialStub"><a class="docstring-binding" href="#CircuitSim.MicrostripRadialStub"><code>CircuitSim.MicrostripRadialStub</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MicrostripRadialStub &lt;: AbstractMicrostripRadialStub</code></pre><p>A microstrip radial (butterfly) stub for wideband matching.</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>n1::Int</code>: Node (connection point)</li><li><code>substrate::Substrate</code>: Substrate definition reference</li><li><code>ri::Real</code>: Inner radius (m)</li><li><code>ro::Real</code>: Outer radius (m)</li><li><code>wf::Real</code>: Feedline width (m)</li><li><code>alpha::Real</code>: Stub angle (degrees)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">sub = Substrate(&quot;FR4&quot;, er=4.5, h=1.6e-3)
stub = MicrostripRadialStub(&quot;RS1&quot;, sub, ri=0.5e-3, ro=5.0e-3, wf=1.0e-3, alpha=60.0)</code></pre><p><strong>Qucs Format</strong></p><p><code>MRSTUB:Name Node1 Subst=&quot;SubstName&quot; ri=&quot;inner&quot; ro=&quot;outer&quot; Wf=&quot;width&quot; alpha=&quot;angle&quot; EffDimens=&quot;OldQucsNoCorrection&quot; Model=&quot;OldQucsModel&quot;</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/components/microstrip_radial_stub.jl#L1-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.MicrostripStep"><a class="docstring-binding" href="#CircuitSim.MicrostripStep"><code>CircuitSim.MicrostripStep</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MicrostripStep &lt;: AbstractMicrostripStep</code></pre><p>A microstrip width step/discontinuity.</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>n1::Int</code>: Node 1 (input, wider/narrower side)</li><li><code>n2::Int</code>: Node 2 (output, other side)</li><li><code>substrate::Substrate</code>: Substrate definition reference</li><li><code>w1::Real</code>: Width at port 1 (m)</li><li><code>w2::Real</code>: Width at port 2 (m)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">sub = Substrate(&quot;FR4&quot;, er=4.5, h=1.6e-3)
step = MicrostripStep(&quot;MSTEP1&quot;, sub, w1=3.0e-3, w2=1.5e-3)</code></pre><p><strong>Qucs Format</strong></p><p><code>MSTEP:Name Node1 Node2 Subst=&quot;SubstName&quot; W1=&quot;width1&quot; W2=&quot;width2&quot;</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/components/microstrip_step.jl#L1-L25">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.MicrostripTee"><a class="docstring-binding" href="#CircuitSim.MicrostripTee"><code>CircuitSim.MicrostripTee</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MicrostripTee &lt;: AbstractMicrostripTee</code></pre><p>A microstrip T-junction (3-port).</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>n1::Int</code>: Node 1 (main line input)</li><li><code>n2::Int</code>: Node 2 (main line output)</li><li><code>n3::Int</code>: Node 3 (branch)</li><li><code>substrate::Substrate</code>: Substrate definition reference</li><li><code>w1::Real</code>: Main line width (m)</li><li><code>w2::Real</code>: Branch width (m)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">sub = Substrate(&quot;FR4&quot;, er=4.5, h=1.6e-3)
tee = MicrostripTee(&quot;MTEE1&quot;, sub, w1=3.0e-3, w2=1.5e-3)</code></pre><p><strong>Qucs Format</strong></p><p><code>MTEE:Name Node1 Node2 Node3 Subst=&quot;SubstName&quot; W1=&quot;width1&quot; W2=&quot;width2&quot; W3=&quot;width3&quot;</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/components/microstrip_tee.jl#L1-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.MicrostripVia"><a class="docstring-binding" href="#CircuitSim.MicrostripVia"><code>CircuitSim.MicrostripVia</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MicrostripVia &lt;: AbstractMicrostripVia</code></pre><p>A microstrip via hole connecting to ground plane.</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>n1::Int</code>: Node (top connection)</li><li><code>substrate::Substrate</code>: Substrate definition reference</li><li><code>d::Real</code>: Via hole diameter (m)</li><li><code>t::Real</code>: Metal thickness (m), uses substrate if 0</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">sub = Substrate(&quot;FR4&quot;, er=4.5, h=1.6e-3)
via = MicrostripVia(&quot;VIA1&quot;, sub, d=0.3e-3)</code></pre><p><strong>Qucs Format</strong></p><p><code>MVIA:Name Node1 gnd Subst=&quot;SubstName&quot; D=&quot;diameter&quot;</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/components/microstrip_via.jl#L1-L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.MultiAnalysisResult"><a class="docstring-binding" href="#CircuitSim.MultiAnalysisResult"><code>CircuitSim.MultiAnalysisResult</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MultiAnalysisResult</code></pre><p>Results from multiple analyses run simultaneously.</p><p>Contains the raw QucsDataset plus typed results for each analysis type found.</p><p><strong>Fields</strong></p><ul><li><code>dataset::QucsDataset</code>: Raw parsed dataset with all vectors</li><li><code>dc::Union{Nothing,DCResult}</code>: DC analysis results (if DC analysis was run)</li><li><code>ac::Union{Nothing,ACResult}</code>: AC analysis results (if AC analysis was run)</li><li><code>transient::Union{Nothing,TransientResult}</code>: Transient analysis results (if transient analysis was run)</li><li><code>sparameter::Union{Nothing,SParameterResult}</code>: S-parameter results (if S-parameter analysis was run)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Run DC + S-parameter analysis together
results = simulate_qucsator(circ, [DCAnalysis(), SParameterAnalysis(1e9, 10e9, 101)])

# Access DC results
if !isnothing(results.dc)
    v_node = results.dc.voltages[&quot;_net1&quot;]
end

# Access S-parameter results
if !isnothing(results.sparameter)
    s21 = results.sparameter.s_matrix[(2,1)]
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/parser/qucs_dataset.jl#L756-L787">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.MultiAnalysisResult-Tuple{QucsDataset, Vector{&lt;:AbstractAnalysis}}"><a class="docstring-binding" href="#CircuitSim.MultiAnalysisResult-Tuple{QucsDataset, Vector{&lt;:AbstractAnalysis}}"><code>CircuitSim.MultiAnalysisResult</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MultiAnalysisResult(dataset::QucsDataset, analyses::Vector{&lt;:AbstractAnalysis})</code></pre><p>Create a MultiAnalysisResult by extracting typed results for each analysis type.</p><p><strong>Arguments</strong></p><ul><li><code>dataset::QucsDataset</code>: Parsed simulation output</li><li><code>analyses::Vector{&lt;:AbstractAnalysis}</code>: List of analyses that were run</li></ul><p><strong>Returns</strong></p><ul><li><code>MultiAnalysisResult</code> with typed results for each analysis found</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/parser/qucs_dataset.jl#L796-L809">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.MutualInductor"><a class="docstring-binding" href="#CircuitSim.MutualInductor"><code>CircuitSim.MutualInductor</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MutualInductor &lt;: AbstractComponent</code></pre><p>Two coupled inductors with mutual inductance.</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>l1::Float64</code>: Inductance of first coil in H</li><li><code>l2::Float64</code>: Inductance of second coil in H</li><li><code>k::Float64</code>: Coupling coefficient (0 to 1, default: 0.9)</li><li><code>n1::Int</code>: First inductor node 1</li><li><code>n2::Int</code>: First inductor node 2</li><li><code>n3::Int</code>: Second inductor node 1</li><li><code>n4::Int</code>: Second inductor node 2</li></ul><p><strong>Pins</strong></p><ul><li><code>:n1</code>, <code>:n2</code>: First inductor</li><li><code>:n3</code>, <code>:n4</code>: Second inductor</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mut = MutualInductor(&quot;MUT1&quot;, l1=1e-6, l2=1e-6, k=0.95)
MutualInductor(&quot;MUT1&quot;, 1.0e-6, 1.0e-6, 0.95, 0, 0, 0, 0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/components/mutual_inductor.jl#L1-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.NoiseAnalysis"><a class="docstring-binding" href="#CircuitSim.NoiseAnalysis"><code>CircuitSim.NoiseAnalysis</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NoiseAnalysis(start, stop, points, output_node, source; type=LOGARITHMIC, name=&quot;Noise1&quot;)</code></pre><p>Noise analysis over a frequency range.</p><p>Computes noise contributions from all noise sources in the circuit.</p><p><strong>Parameters</strong></p><ul><li><code>start::Real</code>: Start frequency in Hz</li><li><code>stop::Real</code>: Stop frequency in Hz</li><li><code>points::Int</code>: Number of frequency points</li><li><code>output_node::String</code>: Output node name for noise measurement</li><li><code>source::String</code>: Input source name for noise reference</li><li><code>sweep_type::SweepType</code>: Type of frequency sweep (default: LOGARITHMIC)</li><li><code>name::String</code>: Analysis name (default: &quot;Noise1&quot;)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Noise analysis from 10Hz to 100kHz
analysis = NoiseAnalysis(10.0, 100e3, 101, &quot;_net1&quot;, &quot;V1&quot;)

# Linear frequency sweep for noise
analysis = NoiseAnalysis(1e3, 10e3, 100, &quot;_net2&quot;, &quot;V_in&quot;, sweep_type=LINEAR)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/analysis/noise_analysis.jl#L1-L27">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.OpAmp"><a class="docstring-binding" href="#CircuitSim.OpAmp"><code>CircuitSim.OpAmp</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">OpAmp &lt;: AbstractComponent</code></pre><p>Operational amplifier with ideal characteristics.</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>g::Float64</code>: Open-loop voltage gain (default: 1e6)</li><li><code>umax::Float64</code>: Maximum output voltage (default: 15.0 V)</li><li><code>ninp::Int</code>: Non-inverting input node</li><li><code>ninn::Int</code>: Inverting input node  </li><li><code>nout::Int</code>: Output node</li></ul><p><strong>Pins</strong></p><ul><li><code>:ninp</code>: Non-inverting input (+)</li><li><code>:ninn</code>: Inverting input (-)</li><li><code>:nout</code>: Output</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; opamp = OpAmp(&quot;OP1&quot;, g=1e5, umax=12.0)
OpAmp(&quot;OP1&quot;, 100000.0, 12.0, 0, 0, 0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/components/opamp.jl#L1-L27">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.Open"><a class="docstring-binding" href="#CircuitSim.Open"><code>CircuitSim.Open</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Open &lt;: AbstractOpenCircuit</code></pre><p>Open circuit (infinite resistance between two nodes).</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>n1::Int</code>: First terminal node</li><li><code>n2::Int</code>: Second terminal node</li></ul><p><strong>Pins</strong></p><ul><li><code>:n1</code>, <code>:n2</code>: Two-terminal open circuit</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; open_ckt = Open(&quot;Open1&quot;)
Open(&quot;Open1&quot;, 0, 0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/components/open.jl#L1-L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.ParameterSweep"><a class="docstring-binding" href="#CircuitSim.ParameterSweep"><code>CircuitSim.ParameterSweep</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ParameterSweep(param, start, stop, points, inner_analysis; type=LINEAR, name=&quot;SW1&quot;)</code></pre><p>Parameter sweep analysis.</p><p>Sweeps a component parameter and runs an inner analysis at each point.</p><p><strong>Parameters</strong></p><ul><li><code>param::String</code>: Parameter name to sweep (e.g., &quot;R1.R&quot; for resistor R1&#39;s resistance)</li><li><code>start::Real</code>: Start value</li><li><code>stop::Real</code>: Stop value  </li><li><code>points::Int</code>: Number of sweep points</li><li><code>inner_analysis::AbstractAnalysis</code>: Analysis to run at each sweep point</li><li><code>sweep_type::SweepType</code>: Type of sweep (LINEAR or LOGARITHMIC, default: LINEAR)</li><li><code>name::String</code>: Analysis name (default: &quot;SW1&quot;)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Sweep R1 from 1kΩ to 10kΩ and run DC analysis at each point
dc = DCAnalysis()
sweep = ParameterSweep(&quot;R1.R&quot;, 1e3, 10e3, 10, dc)
result = simulate_qucsator(circuit, sweep)

# Logarithmic parameter sweep with AC inner analysis
ac = ACAnalysis(1.0, 1e6, 101)
sweep = ParameterSweep(&quot;C1.C&quot;, 1e-12, 1e-9, 20, ac, sweep_type=LOGARITHMIC)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/analysis/parameter_sweep.jl#L1-L30">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.PhaseShifter"><a class="docstring-binding" href="#CircuitSim.PhaseShifter"><code>CircuitSim.PhaseShifter</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PhaseShifter &lt;: AbstractPhaseShifter</code></pre><p>RF phase shifter.</p><p>A phase shifter introduces a specified phase shift to the signal while maintaining amplitude (ideally).</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>n1::Int</code>: Input terminal node number</li><li><code>n2::Int</code>: Output terminal node number</li><li><code>phase::Real</code>: Phase shift in degrees</li><li><code>z0::Real</code>: Reference impedance in Ohms (default: 50)</li><li><code>insertion_loss::Real</code>: Insertion loss in dB (default: 0 for ideal)</li></ul><p><strong>Example</strong></p><pre><code class="language- hljs">using CircuitSim
# 90 degree phase shifter
PS1 = PhaseShifter(&quot;PS1&quot;, 90.0)

# 180 degree phase shifter with 0.5 dB loss
PS2 = PhaseShifter(&quot;PS2&quot;, 180.0, insertion_loss=0.5)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/components/phase_shifter.jl#L1-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.Pin"><a class="docstring-binding" href="#CircuitSim.Pin"><code>CircuitSim.Pin</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Pin representation: (component, fieldname)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/pin.jl#L1-L3">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.PowerProbe"><a class="docstring-binding" href="#CircuitSim.PowerProbe"><code>CircuitSim.PowerProbe</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Power probe for measuring power flow in circuits.</p><p>The probe measures power between two differential ports (4 terminals total).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/probes/power_probe.jl#L1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.QucsDataset"><a class="docstring-binding" href="#CircuitSim.QucsDataset"><code>CircuitSim.QucsDataset</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">QucsDataset</code></pre><p>Parsed simulation result containing all vectors and metadata.</p><p><strong>Fields</strong></p><ul><li><code>status::SimulationStatus</code>: Status of the simulation</li><li><code>version::String</code>: Qucs dataset version</li><li><code>independent_vars::Dict{String,DataVector}</code>: Independent variables (e.g., frequency, time)</li><li><code>dependent_vars::Dict{String,DataVector}</code>: Dependent variables (e.g., voltages, currents)</li><li><code>errors::Vector{String}</code>: Error messages</li><li><code>warnings::Vector{String}</code>: Warning messages</li><li><code>raw_output::String</code>: Raw simulator output</li></ul><p><strong>Typed Result Extraction</strong></p><p>Use <code>extract_dc_result()</code>, <code>extract_ac_result()</code>, <code>extract_transient_result()</code>,  or <code>extract_sparameter_result()</code> to get typed data structures.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/parser/qucs_dataset.jl#L114-L133">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.Resistor"><a class="docstring-binding" href="#CircuitSim.Resistor"><code>CircuitSim.Resistor</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Resistor &lt;: AbstractResistor</code></pre><p>Ideal resistor with two terminals.</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>n1::Int</code>: First terminal node number (assigned during circuit analysis)</li><li><code>n2::Int</code>: Second terminal node number (assigned during circuit analysis)</li><li><code>resistance::Real</code>: Resistance in Ohms</li><li><code>temp::Real</code>: Operating temperature in Kelvin (default: 26.85)</li><li><code>tc1::Real</code>: First order temperature coefficient (default: 0.0)</li><li><code>tc2::Real</code>: Second order temperature coefficient (default: 0.0)</li><li><code>tnom::Real</code>: Nominal temperature in Kelvin (default: 26.85)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">R1 = Resistor(&quot;R1&quot;, 1000.0)  # 1kΩ resistor
R2 = Resistor(&quot;R2&quot;, 2200.0, 85.0, 0.001, 0.0, 25.0)  # 2.2kΩ resistor with temperature coefficients</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/components/resistor.jl#L1-L23">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.SParameterAnalysis"><a class="docstring-binding" href="#CircuitSim.SParameterAnalysis"><code>CircuitSim.SParameterAnalysis</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SParameterAnalysis(start, stop, points; type=LOGARITHMIC, name=&quot;SP1&quot;, z0=50.0, noise=false, noise_input_port=1, noise_output_port=2)</code></pre><p>S-parameter frequency sweep analysis.</p><p>Computes S-parameters over a frequency range. Optionally compute noise parameters.</p><p><strong>Parameters</strong></p><ul><li><code>start::Real</code>: Start frequency in Hz</li><li><code>stop::Real</code>: Stop frequency in Hz</li><li><code>points::Int</code>: Number of frequency points</li><li><code>sweep_type::SweepType</code>: Type of frequency sweep (LINEAR or LOGARITHMIC, default: LOGARITHMIC)</li><li><code>z0::Real</code>: Reference impedance in Ohms (default: 50.0)</li><li><code>noise::Bool</code>: Enable noise parameter calculation (default: false)</li><li><code>noise_input_port::Int</code>: Input port for noise parameters (default: 1)</li><li><code>noise_output_port::Int</code>: Output port for noise parameters (default: 2)</li><li><code>name::String</code>: Analysis name (default: &quot;SP1&quot;)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># S-parameter analysis from 1MHz to 1GHz
analysis = SParameterAnalysis(1e6, 1e9, 201)

# With 75Ω reference impedance
analysis = SParameterAnalysis(1e6, 1e9, 201, z0=75.0)

# With noise parameters (F, Fmin, Sopt, Rn)
analysis = SParameterAnalysis(1e6, 1e9, 201, noise=true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/analysis/s_parameter_analysis.jl#L1-L32">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.SParameterResult"><a class="docstring-binding" href="#CircuitSim.SParameterResult"><code>CircuitSim.SParameterResult</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SParameterResult</code></pre><p>S-parameter analysis results.</p><p><strong>Fields</strong></p><ul><li><code>frequencies_Hz::Vector{Float64}</code>: Frequency points</li><li><code>num_ports::Int</code>: Number of ports</li><li><code>s_matrix::Dict{Tuple{Int,Int},Vector{ComplexF64}}</code>: S[i,j] vs frequency</li><li><code>z0_Ohm::Float64</code>: Reference impedance</li><li><code>F::Union{Nothing,Vector{Float64}}</code>: Noise figure (linear, not dB) vs frequency (if noise analysis enabled)</li><li><code>Fmin::Union{Nothing,Vector{Float64}}</code>: Minimum noise figure (linear) vs frequency (if noise analysis enabled)</li><li><code>Sopt::Union{Nothing,Vector{ComplexF64}}</code>: Optimal source reflection coefficient vs frequency (if noise analysis enabled)</li><li><code>Rn_Ohm::Union{Nothing,Vector{Float64}}</code>: Equivalent noise resistance in Ohms vs frequency (if noise analysis enabled)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/parser/qucs_dataset.jl#L68-L83">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.SPfile"><a class="docstring-binding" href="#CircuitSim.SPfile"><code>CircuitSim.SPfile</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SPfile &lt;: AbstractSParameterFile</code></pre><p>S-parameter file (Touchstone format) component.</p><p>Loads S-parameters from a Touchstone file and uses them as a  black-box frequency-domain model. The number of ports is automatically  detected from the file extension.</p><p><strong>Port Structure</strong></p><p>For an N-port S-parameter file, the component has N+1 nodes:</p><ul><li><code>n1</code>, <code>n2</code>, ..., <code>nN</code>: Port terminal nodes</li><li><code>ref</code>: Ground reference node (always the last node)</li></ul><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>nodes::Vector{Int}</code>: Port terminal nodes (N+1 total: N ports + ground)</li><li><code>file::String</code>: Path to Touchstone file</li><li><code>num_ports::Int</code>: Number of ports</li><li><code>data_format::String</code>: Data format (&quot;rectangular&quot; or &quot;polar&quot;)</li><li><code>interpolator::String</code>: Interpolation method (&quot;linear&quot; or &quot;cubic&quot;)</li><li><code>temp::Real</code>: Temperature in Kelvin (default 293.15K = 20°C)</li><li><code>during_dc::String</code>: DC behavior (&quot;open&quot;, &quot;short&quot;, or &quot;unspecified&quot;)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Load a 1-port S-parameter file (antenna)
antenna = SPfile(&quot;ANT1&quot;, &quot;antenna.s1p&quot;)
@connect circ source.nplus antenna.n1
@connect circ antenna.ref ground

# Load a 2-port S-parameter file (amplifier)
amp = SPfile(&quot;AMP1&quot;, &quot;amplifier.s2p&quot;)
@connect circ input.nplus amp.n1
@connect circ output.nplus amp.n2
@connect circ amp.ref ground

# Manually specify port count if filename doesn&#39;t follow .sNp convention
custom = SPfile(&quot;DEV&quot;, &quot;data.txt&quot;, num_ports=3)

# Custom options
filter_sp = SPfile(&quot;FILT1&quot;, &quot;filter.s2p&quot;, 
    data_format=&quot;polar&quot;,
    interpolator=&quot;cubic&quot;,
    temp=298.15)</code></pre><p><strong>Notes</strong></p><ul><li>File path can be absolute or relative to netlist location</li><li>Supports Touchstone v1.0, v1.1, v2.0 formats</li><li>Number of ports detected from .sNp filename (e.g., .s1p = 1-port, .s2p = 2-port)</li><li>Can be overridden with <code>num_ports</code> parameter</li><li>Always connect the <code>ref</code> node to circuit ground</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/components/spfile.jl#L1-L58">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.SimulationStatus"><a class="docstring-binding" href="#CircuitSim.SimulationStatus"><code>CircuitSim.SimulationStatus</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SimulationStatus</code></pre><p>Result status from a simulation run.</p><p>Values:</p><ul><li><code>SIM_SUCCESS</code>: Simulation completed successfully</li><li><code>SIM_ERROR</code>: Simulation encountered an error</li><li><code>SIM_PARSE_ERROR</code>: Output parsing failed</li><li><code>SIM_NOT_RUN</code>: Simulation has not been run</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/parser/qucs_dataset.jl#L1-L11">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.SpiralInductor"><a class="docstring-binding" href="#CircuitSim.SpiralInductor"><code>CircuitSim.SpiralInductor</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SpiralInductor &lt;: AbstractSpiralInductor</code></pre><p>A planar spiral inductor on a substrate.</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>n1::Int</code>: Node 1 (outer terminal)</li><li><code>n2::Int</code>: Node 2 (inner terminal)</li><li><code>substrate::Substrate</code>: Substrate definition reference</li><li><code>geometry::String</code>: Inductor geometry (&quot;Circular&quot;, &quot;Square&quot;, &quot;Hexagonal&quot;, &quot;Octogonal&quot;)</li><li><code>w::Real</code>: Track width (m)</li><li><code>s::Real</code>: Track spacing (m)</li><li><code>di::Real</code>: Inner diameter (m)</li><li><code>turns::Real</code>: Number of turns</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">sub = Substrate(&quot;FR4&quot;, er=4.5, h=1.6e-3)
spiral = SpiralInductor(&quot;L1&quot;, sub, geometry=&quot;Circular&quot;, w=0.2e-3, s=0.15e-3, di=1e-3, turns=5.5)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/components/spiral_inductor.jl#L1-L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.Substrate"><a class="docstring-binding" href="#CircuitSim.Substrate"><code>CircuitSim.Substrate</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Substrate</code></pre><p>Defines the substrate properties for microstrip and planar components.</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Substrate identifier</li><li><code>er::Real</code>: Relative permittivity (dielectric constant)</li><li><code>h::Real</code>: Substrate height/thickness in meters</li><li><code>t::Real</code>: Metal thickness in meters</li><li><code>tand::Real</code>: Loss tangent (tan δ)</li><li><code>rho::Real</code>: Metal resistivity in Ω·m (Copper ≈ 0.022e-6)</li><li><code>rough::Real</code>: Surface roughness in meters</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Standard FR4 substrate
fr4 = Substrate(&quot;FR4&quot;, er=4.5, h=1.6e-3, t=35e-6, tand=0.02)

# Rogers RO4003C
ro4003c = Substrate(&quot;RO4003C&quot;, er=3.55, h=0.508e-3, t=17e-6, tand=0.0027)

# Low-loss Rogers RT/duroid
duroid = Substrate(&quot;Duroid&quot;, er=2.2, h=0.787e-3, t=35e-6, tand=0.0009)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/components/substrate.jl#L1-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.SweepType"><a class="docstring-binding" href="#CircuitSim.SweepType"><code>CircuitSim.SweepType</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SweepType</code></pre><p>Sweep type for frequency or parameter sweeps.</p><p>Values:</p><ul><li><code>LINEAR</code>: Linear sweep</li><li><code>LOGARITHMIC</code>: Logarithmic sweep</li><li><code>LIST</code>: List of discrete values</li><li><code>CONSTANT</code>: Single constant value</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/analysis/analysis_types.jl#L16-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.TransientAnalysis"><a class="docstring-binding" href="#CircuitSim.TransientAnalysis"><code>CircuitSim.TransientAnalysis</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TransientAnalysis(stop; start=0.0, points=nothing, step=nothing, name=&quot;TR1&quot;)</code></pre><p>Time-domain transient analysis.</p><p>Simulates the circuit behavior over time.</p><p><strong>Parameters</strong></p><ul><li><code>stop::Real</code>: Stop time in seconds</li><li><code>start::Real</code>: Start time in seconds (default: 0.0)</li><li><code>points::Int</code>: Number of time points (specify either points or step)</li><li><code>step::Real</code>: Time step in seconds (specify either points or step)</li><li><code>name::String</code>: Analysis name (default: &quot;TR1&quot;)</li><li><code>initial_dc::Bool</code>: Compute initial DC operating point (default: true)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Simulate for 1ms with 1001 points
analysis = TransientAnalysis(1e-3, points=1001)

# Simulate for 10μs with 10ns step
analysis = TransientAnalysis(10e-6, step=10e-9)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/analysis/transient_analysis.jl#L1-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.TransientResult"><a class="docstring-binding" href="#CircuitSim.TransientResult"><code>CircuitSim.TransientResult</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TransientResult</code></pre><p>Transient analysis results (time domain).</p><p><strong>Fields</strong></p><ul><li><code>time_s::Vector{Float64}</code>: Time points</li><li><code>voltages::Dict{String,Vector{Float64}}</code>: Node voltages vs time</li><li><code>currents::Dict{String,Vector{Float64}}</code>: Branch currents vs time</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/parser/qucs_dataset.jl#L51-L61">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.TransmissionLine"><a class="docstring-binding" href="#CircuitSim.TransmissionLine"><code>CircuitSim.TransmissionLine</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TransmissionLine &lt;: AbstractComponent</code></pre><p>Simple lossless transmission line.</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>z0::Float64</code>: Characteristic impedance in Ω (default: 50.0)</li><li><code>length_m::Float64</code>: Physical length in meters</li><li><code>alpha::Float64</code>: Attenuation constant in 1/m (default: 0.0)</li><li><code>n1::Int</code>: Input port positive node</li><li><code>n2::Int</code>: Input port negative node</li><li><code>n3::Int</code>: Output port positive node</li><li><code>n4::Int</code>: Output port negative node</li></ul><p><strong>Pins</strong></p><ul><li><code>:n1</code>, <code>:n2</code>: Input port</li><li><code>:n3</code>, <code>:n4</code>: Output port</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; tline = TransmissionLine(&quot;TL1&quot;, z0=75.0, length_m=0.1)
TransmissionLine(&quot;TL1&quot;, 75.0, 0.1, 0.0, 0, 0, 0, 0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/components/transmission_line.jl#L1-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.VoltageAMSource"><a class="docstring-binding" href="#CircuitSim.VoltageAMSource"><code>CircuitSim.VoltageAMSource</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">VoltageAMSource(name::String; u::Real=1.0, f::Real=1e9, m::Real=1.0, phase::Real=0.0)</code></pre><p>Create an amplitude modulated voltage source with 3-port configuration.</p><p><strong>Arguments</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>u::Real</code>: Carrier amplitude in Volts (default 1.0)</li><li><code>f::Real</code>: Carrier frequency in Hz (default 1e9)</li><li><code>m::Real</code>: Modulation index 0 to 1 (default 1.0)</li><li><code>phase::Real</code>: Phase in degrees -360 to 360 (default 0.0)</li></ul><p><strong>Fields</strong></p><ul><li><code>nplus::Int</code>: Positive output node</li><li><code>nminus::Int</code>: Negative output node</li><li><code>nmod::Int</code>: Modulation input node</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/sources/voltage_am_source.jl#L1-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.VoltageControlledCurrentSource"><a class="docstring-binding" href="#CircuitSim.VoltageControlledCurrentSource"><code>CircuitSim.VoltageControlledCurrentSource</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">VoltageControlledCurrentSource(name::String; g::Real=1.0, t::Real=0.0)</code></pre><p>Create a voltage-controlled current source with 4-port configuration.</p><p><strong>Arguments</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>g::Real</code>: Transconductance in Siemens (A/V) (default 1.0)</li><li><code>t::Real</code>: Time delay in seconds (default 0.0)</li></ul><p><strong>Fields</strong></p><ul><li><code>n1::Int</code>: Positive input control node</li><li><code>n2::Int</code>: Negative input control node</li><li><code>n3::Int</code>: Positive output node</li><li><code>n4::Int</code>: Negative output node</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/sources/voltage_controlled_current_source.jl#L1-L18">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.VoltageControlledVoltageSource"><a class="docstring-binding" href="#CircuitSim.VoltageControlledVoltageSource"><code>CircuitSim.VoltageControlledVoltageSource</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">VoltageControlledVoltageSource(name::String; g::Real=1.0, t::Real=0.0)</code></pre><p>Create a voltage-controlled voltage source with 4-port configuration.</p><p><strong>Arguments</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>g::Real</code>: Voltage gain (default 1.0)</li><li><code>t::Real</code>: Time delay in seconds (default 0.0)</li></ul><p><strong>Fields</strong></p><ul><li><code>n1::Int</code>: Positive input control node</li><li><code>n2::Int</code>: Negative input control node  </li><li><code>n3::Int</code>: Positive output node</li><li><code>n4::Int</code>: Negative output node</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/sources/voltage_controlled_voltage_source.jl#L1-L18">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.VoltageExponentialSource"><a class="docstring-binding" href="#CircuitSim.VoltageExponentialSource"><code>CircuitSim.VoltageExponentialSource</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">VoltageExponentialSource &lt;: AbstractVoltageSource</code></pre><p>Exponential rise/fall voltage source for transient analysis.</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>n1::Int</code>: Positive terminal node number</li><li><code>n2::Int</code>: Negative terminal node number</li><li><code>u1::Real</code>: Initial voltage level (V)</li><li><code>u2::Real</code>: Final voltage level (V)</li><li><code>t1::Real</code>: Rise delay time (s)</li><li><code>t2::Real</code>: Fall delay time (s)</li><li><code>tr::Real</code>: Rise time constant (s, optional, default 1ns)</li><li><code>tf::Real</code>: Fall time constant (s, optional, default 1ns)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">vsrc = VoltageExponentialSource(&quot;Vexp1&quot;, u1=0.0, u2=5.0, t1=1e-9, t2=10e-9)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/sources/voltage_exponential_source.jl#L1-L23">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.VoltageNoiseSource"><a class="docstring-binding" href="#CircuitSim.VoltageNoiseSource"><code>CircuitSim.VoltageNoiseSource</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">VoltageNoiseSource &lt;: AbstractVoltageSource</code></pre><p>Voltage noise source for noise analysis with frequency-dependent PSD.</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>n1::Int</code>: Positive terminal node number</li><li><code>n2::Int</code>: Negative terminal node number</li><li><code>u::Real</code>: Noise power spectral density (V²/Hz)</li><li><code>a::Real</code>: Frequency offset parameter (optional, default 0)</li><li><code>c::Real</code>: Frequency coefficient (optional, default 1)</li><li><code>e::Real</code>: Frequency exponent (optional, default 0)</li></ul><p>Noise PSD formula: PSD(f) = u / (a + c * f^e)</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">vsrc = VoltageNoiseSource(&quot;Vnoise1&quot;, u=1e-6, e=0)  # White noise</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/sources/voltage_noise_source.jl#L1-L21">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.VoltagePMSource"><a class="docstring-binding" href="#CircuitSim.VoltagePMSource"><code>CircuitSim.VoltagePMSource</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">VoltagePMSource(name::String; u::Real=1.0, f::Real=1e9, m::Real=1.0, phase::Real=0.0)</code></pre><p>Create a phase modulated voltage source with 3-port configuration.</p><p><strong>Arguments</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>u::Real</code>: Carrier amplitude in Volts (default 1.0)</li><li><code>f::Real</code>: Carrier frequency in Hz (default 1e9)</li><li><code>m::Real</code>: Modulation index 0 to 1 (default 1.0)</li><li><code>phase::Real</code>: Base phase in degrees -360 to 360 (default 0.0)</li></ul><p><strong>Fields</strong></p><ul><li><code>nplus::Int</code>: Positive output node</li><li><code>nminus::Int</code>: Negative output node</li><li><code>nmod::Int</code>: Modulation input node</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/sources/voltage_pm_source.jl#L1-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.VoltageProbe"><a class="docstring-binding" href="#CircuitSim.VoltageProbe"><code>CircuitSim.VoltageProbe</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Voltage probe for measuring voltages in AC, DC, and transient analyses.</p><p>The probe connects between two nodes and measures the voltage difference. It has infinite input impedance (does not affect the circuit).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/probes/voltage_probe.jl#L1-L6">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.VoltagePulseSource"><a class="docstring-binding" href="#CircuitSim.VoltagePulseSource"><code>CircuitSim.VoltagePulseSource</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">VoltagePulseSource &lt;: AbstractVoltageSource</code></pre><p>Voltage source with pulse waveform for transient analysis.</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>n1::Int</code>: Positive terminal node number</li><li><code>n2::Int</code>: Negative terminal node number</li><li><code>u1::Real</code>: Initial voltage level (V)</li><li><code>u2::Real</code>: Pulsed voltage level (V)</li><li><code>t1::Real</code>: Start time of pulse (s)</li><li><code>t2::Real</code>: End time of pulse (s)</li><li><code>tr::Real</code>: Rise time (s, optional, default 1ns)</li><li><code>tf::Real</code>: Fall time (s, optional, default 1ns)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">vsrc = VoltagePulseSource(&quot;Vpulse1&quot;, u1=0.0, u2=5.0, t1=1e-9, t2=10e-9, tr=1e-10, tf=1e-10)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/sources/voltage_pulse_source.jl#L1-L23">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.VoltageRectangularSource"><a class="docstring-binding" href="#CircuitSim.VoltageRectangularSource"><code>CircuitSim.VoltageRectangularSource</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">VoltageRectangularSource &lt;: AbstractVoltageSource</code></pre><p>Periodic rectangular pulse voltage source for transient analysis.</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>n1::Int</code>: Positive terminal node number</li><li><code>n2::Int</code>: Negative terminal node number</li><li><code>u::Real</code>: Pulse voltage level (V)</li><li><code>th::Real</code>: High time duration (s)</li><li><code>tl::Real</code>: Low time duration (s)</li><li><code>tr::Real</code>: Rise time (s, optional, default 1ns)</li><li><code>tf::Real</code>: Fall time (s, optional, default 1ns)</li><li><code>td::Real</code>: Delay time (s, optional, default 0)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">vsrc = VoltageRectangularSource(&quot;Vrect1&quot;, u=5.0, th=1e-6, tl=1e-6)</code></pre><p><strong>Qucs Format</strong></p><p><code>Vrect:Name Node+ Node- U=&quot;u&quot; TH=&quot;th&quot; TL=&quot;tl&quot; Tr=&quot;tr&quot; Tf=&quot;tf&quot; Td=&quot;td&quot;</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/sources/voltage_rectangular_source.jl#L5-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.VoltageVoltageNoiseSource"><a class="docstring-binding" href="#CircuitSim.VoltageVoltageNoiseSource"><code>CircuitSim.VoltageVoltageNoiseSource</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">VoltageVoltageNoiseSource(name::String; v1::Real=1e-6, v2::Real=1e-6, c_corr::Real=0.0, a::Real=0.0, c::Real=1.0, e::Real=0.0)</code></pre><p>Create correlated voltage-voltage noise sources with 4-port configuration.</p><p><strong>Arguments</strong></p><ul><li><code>name::String</code>: Component identifier</li><li><code>v1::Real</code>: RMS voltage of first source in V (default 1e-6)</li><li><code>v2::Real</code>: RMS voltage of second source in V (default 1e-6)</li><li><code>c_corr::Real</code>: Correlation coefficient -1 to 1 (default 0.0)</li><li><code>a::Real</code>: Flicker noise exponent (default 0.0)</li><li><code>c::Real</code>: Flicker noise coefficient (default 1.0)</li><li><code>e::Real</code>: Flicker noise frequency exponent (default 0.0)</li></ul><p><strong>Fields</strong></p><ul><li><code>v1plus::Int</code>: Positive node of first voltage source</li><li><code>v1minus::Int</code>: Negative node of first voltage source</li><li><code>v2plus::Int</code>: Positive node of second voltage source</li><li><code>v2minus::Int</code>: Negative node of second voltage source</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/sources/voltage_voltage_noise_source.jl#L1-L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.add_component!-Tuple{Circuit, Any}"><a class="docstring-binding" href="#CircuitSim.add_component!-Tuple{Circuit, Any}"><code>CircuitSim.add_component!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Add a component to the circuit (if not already added)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/circuit.jl#L12-L14">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.assign_nodes!-Tuple{Circuit}"><a class="docstring-binding" href="#CircuitSim.assign_nodes!-Tuple{Circuit}"><code>CircuitSim.assign_nodes!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Walk all components, examine their integer fields (node fields), and assign canonical node numbers (small consecutive integers). Ground is node 0. After calling assign_nodes!, the components&#39; node fields are filled with integers suitable for netlisting.</p><p>Node fields are identified by name pattern: n, n1, n2, nplus, nminus, etc. Other Int fields (like port numbers) are left unchanged.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/circuit.jl#L70-L76">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.check_ngspice-Tuple{}"><a class="docstring-binding" href="#CircuitSim.check_ngspice-Tuple{}"><code>CircuitSim.check_ngspice</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">check_ngspice() -&gt; (Bool, String, String)</code></pre><p>Check if ngspice is installed and available in PATH.</p><p><strong>Returns</strong></p><ul><li><code>is_installed::Bool</code>: Whether ngspice is available</li><li><code>version::String</code>: Version string if available</li><li><code>path::String</code>: Path to the executable</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/backends/ngspice.jl#L1-L10">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.check_qucsator-Tuple{}"><a class="docstring-binding" href="#CircuitSim.check_qucsator-Tuple{}"><code>CircuitSim.check_qucsator</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">check_qucsator() -&gt; (Bool, String, String)</code></pre><p>Check if qucsator_rf is installed and available in PATH.</p><p><strong>Returns</strong></p><ul><li><code>is_installed::Bool</code>: Whether qucsator_rf is available</li><li><code>version::String</code>: Version string if available</li><li><code>path::String</code>: Path to the executable</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/backends/qucsator.jl#L1-L10">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.connect!-Tuple{Circuit, Any, Symbol, Any, Symbol}"><a class="docstring-binding" href="#CircuitSim.connect!-Tuple{Circuit, Any, Symbol, Any, Symbol}"><code>CircuitSim.connect!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>A convenience overload that accepts component + symbol pairs:</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/circuit.jl#L36-L38">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.connect!-Tuple{Circuit, Pin, Pin}"><a class="docstring-binding" href="#CircuitSim.connect!-Tuple{Circuit, Pin, Pin}"><code>CircuitSim.connect!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Connect two pins in the circuit. The components will be added if not present.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/circuit.jl#L26-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.detect_format-Tuple{String}"><a class="docstring-binding" href="#CircuitSim.detect_format-Tuple{String}"><code>CircuitSim.detect_format</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">detect_format(filepath::String) -&gt; Symbol</code></pre><p>Detect file format by examining file content.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/io/file_loader.jl#L96-L100">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.detect_touchstone_ports-Tuple{String}"><a class="docstring-binding" href="#CircuitSim.detect_touchstone_ports-Tuple{String}"><code>CircuitSim.detect_touchstone_ports</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">detect_touchstone_ports(filepath::String) -&gt; Int</code></pre><p>Detect the number of ports from Touchstone file extension using regex.</p><p>Matches filenames ending in .sNp where N is 1 or more digits (e.g., .s1p, .s2p, .s12p).</p><p>Throws an error if pattern doesn&#39;t match.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; detect_touchstone_ports(&quot;antenna.s1p&quot;)
1

julia&gt; detect_touchstone_ports(&quot;amplifier.s2p&quot;)
2

julia&gt; detect_touchstone_ports(&quot;complex_device.txt&quot;)
ERROR: ArgumentError: Could not detect number of ports from filename &#39;complex_device.txt&#39;. Expected Touchstone format: .sNp (e.g., .s1p, .s2p). Provide num_ports parameter as override.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/utilities.jl#L133-L154">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.extract_ac_result-Tuple{QucsDataset}"><a class="docstring-binding" href="#CircuitSim.extract_ac_result-Tuple{QucsDataset}"><code>CircuitSim.extract_ac_result</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">extract_ac_result(dataset::QucsDataset) -&gt; ACResult</code></pre><p>Extract AC analysis results from dataset.</p><p><strong>Returns</strong></p><ul><li><code>ACResult</code> with frequency sweep data</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">ac_data = extract_ac_result(dataset)
freqs = ac_data.frequencies_Hz
v_out = ac_data.voltages[&quot;_net1&quot;]  # ComplexF64 vector vs frequency</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/parser/qucs_dataset.jl#L626-L642">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.extract_dc_result-Tuple{QucsDataset}"><a class="docstring-binding" href="#CircuitSim.extract_dc_result-Tuple{QucsDataset}"><code>CircuitSim.extract_dc_result</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">extract_dc_result(dataset::QucsDataset) -&gt; DCResult</code></pre><p>Extract DC operating point results from dataset.</p><p><strong>Returns</strong></p><ul><li><code>DCResult</code> with voltages and currents dictionaries</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">dc_data = extract_dc_result(dataset)
v_out = dc_data.voltages[&quot;_net1&quot;]
i_supply = dc_data.currents[&quot;V1&quot;]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/parser/qucs_dataset.jl#L579-L595">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.extract_sparameter_result-Tuple{QucsDataset}"><a class="docstring-binding" href="#CircuitSim.extract_sparameter_result-Tuple{QucsDataset}"><code>CircuitSim.extract_sparameter_result</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">extract_sparameter_result(dataset::QucsDataset; z0::Real=50.0) -&gt; SParameterResult</code></pre><p>Extract S-parameter analysis results from dataset.</p><p><strong>Arguments</strong></p><ul><li><code>dataset::QucsDataset</code>: Parsed simulation output</li><li><code>z0::Real=50.0</code>: Reference impedance in Ohms</li></ul><p><strong>Returns</strong></p><ul><li><code>SParameterResult</code> with S-parameter matrix data and noise parameters (if noise analysis was enabled)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">sp_data = extract_sparameter_result(dataset)
freqs = sp_data.frequencies_Hz
s21 = sp_data.s_matrix[(2,1)]  # Forward transmission vs frequency

# Noise parameters (if available)
if !isnothing(sp_data.F)
    nf_db = 10 * log10.(sp_data.F)  # Convert to dB
    fmin_db = 10 * log10.(sp_data.Fmin)  # Minimum NF in dB
    gamma_opt = sp_data.Sopt  # Optimal source reflection coefficient
    rn = sp_data.Rn_Ohm  # Equivalent noise resistance
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/parser/qucs_dataset.jl#L700-L729">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.extract_transient_result-Tuple{QucsDataset}"><a class="docstring-binding" href="#CircuitSim.extract_transient_result-Tuple{QucsDataset}"><code>CircuitSim.extract_transient_result</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">extract_transient_result(dataset::QucsDataset) -&gt; TransientResult</code></pre><p>Extract transient analysis results from dataset.</p><p><strong>Returns</strong></p><ul><li><code>TransientResult</code> with time domain data</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">tran_data = extract_transient_result(dataset)
times = tran_data.time_s
v_out = tran_data.voltages[&quot;_net1&quot;]  # Float64 vector vs time</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/parser/qucs_dataset.jl#L663-L679">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.format_value-Tuple{Real}"><a class="docstring-binding" href="#CircuitSim.format_value-Tuple{Real}"><code>CircuitSim.format_value</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Simple formatting helper for numeric values</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/utilities.jl#L1-L3">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.get_complex_vector-Tuple{QucsDataset, String}"><a class="docstring-binding" href="#CircuitSim.get_complex_vector-Tuple{QucsDataset, String}"><code>CircuitSim.get_complex_vector</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_complex_vector(dataset::QucsDataset, name::String) -&gt; Vector{ComplexF64}</code></pre><p>Get the complex values of a named vector from the dataset.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/parser/qucs_dataset.jl#L341-L345">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.get_component_current-Tuple{Union{ACResult, DCResult, TransientResult}, String}"><a class="docstring-binding" href="#CircuitSim.get_component_current-Tuple{Union{ACResult, DCResult, TransientResult}, String}"><code>CircuitSim.get_component_current</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_component_current(result, component_name::String)</code></pre><p>Get current through a component from simulation results.</p><p>Note: Current direction follows passive sign convention - positive current flows from the first pin (e.g., nplus, n1) to the second pin (e.g., nminus, n2) internally.</p><p><strong>Arguments</strong></p><ul><li><code>result</code>: DCResult, ACResult, or TransientResult</li><li><code>component_name::String</code>: Component name (e.g., &quot;V1&quot;, &quot;R1&quot;)</li></ul><p><strong>Returns</strong></p><ul><li>For DC: Float64 current</li><li>For AC: Vector{ComplexF64} current vs frequency</li><li>For Transient: Vector{Float64} current vs time</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">dc = simulate_qucsator(circ, DCAnalysis())
i_source = get_component_current(dc, &quot;V1&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/parser/simulation_result.jl#L32-L57">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.get_component_power-Tuple{DCResult, Any, Symbol, Symbol}"><a class="docstring-binding" href="#CircuitSim.get_component_power-Tuple{DCResult, Any, Symbol, Symbol}"><code>CircuitSim.get_component_power</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_component_power(result::DCResult, component, pin_pos::Symbol, pin_neg::Symbol)</code></pre><p>Calculate power dissipated in a component for DC analysis (P = V × I).</p><p><strong>Arguments</strong></p><ul><li><code>result::DCResult</code>: DC analysis result</li><li><code>component</code>: Component instance</li><li><code>pin_pos::Symbol</code>: Positive pin name</li><li><code>pin_neg::Symbol</code>: Negative pin name</li></ul><p><strong>Returns</strong></p><ul><li>Float64: Power in watts (positive = dissipated, negative = generated)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">R1 = Resistor(&quot;R1&quot;, 100.0)
# ... build and simulate circuit ...
dc = simulate_qucsator(circ, DCAnalysis())
power = get_component_power(dc, R1, :n1, :n2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/parser/simulation_result.jl#L231-L255">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.get_frequency-Tuple{QucsDataset}"><a class="docstring-binding" href="#CircuitSim.get_frequency-Tuple{QucsDataset}"><code>CircuitSim.get_frequency</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_frequency(dataset::QucsDataset) -&gt; Vector{Float64}</code></pre><p>Get the frequency vector for S-parameter, AC, or other frequency-domain analyses. Looks for &#39;frequency&#39;, &#39;acfrequency&#39;, or &#39;hbfrequency&#39; (for HB analysis, returns unique frequencies).</p><p><strong>Returns</strong></p><ul><li>Vector of frequency values in Hz</li></ul><p><strong>Throws</strong></p><ul><li>ErrorException if no frequency vector found</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/parser/qucs_dataset.jl#L418-L431">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.get_imag_vector-Tuple{QucsDataset, String}"><a class="docstring-binding" href="#CircuitSim.get_imag_vector-Tuple{QucsDataset, String}"><code>CircuitSim.get_imag_vector</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_imag_vector(dataset::QucsDataset, name::String) -&gt; Vector{Float64}</code></pre><p>Extract imaginary parts of a named vector from the dataset.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/parser/qucs_dataset.jl#L326-L330">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.get_node_voltage-Tuple{QucsDataset, String}"><a class="docstring-binding" href="#CircuitSim.get_node_voltage-Tuple{QucsDataset, String}"><code>CircuitSim.get_node_voltage</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_node_voltage(dataset::QucsDataset, node_name::String) -&gt; Vector{ComplexF64}</code></pre><p>Get voltage at a named node.</p><p><strong>Arguments</strong></p><ul><li><code>dataset::QucsDataset</code>: The simulation results  </li><li><code>node_name::String</code>: Node name (e.g., &quot;net1&quot;, &quot;vout&quot;)</li></ul><p><strong>Returns</strong></p><ul><li>Vector of complex voltage values</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">v_out = get_node_voltage(result, &quot;net5&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/parser/qucs_dataset.jl#L510-L529">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.get_node_voltage-Tuple{Union{ACResult, DCResult, TransientResult}, String}"><a class="docstring-binding" href="#CircuitSim.get_node_voltage-Tuple{Union{ACResult, DCResult, TransientResult}, String}"><code>CircuitSim.get_node_voltage</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_node_voltage(result, node_name::String)</code></pre><p>Get voltage at a specific node from simulation results.</p><p><strong>Arguments</strong></p><ul><li><code>result</code>: DCResult, ACResult, or TransientResult</li><li><code>node_name::String</code>: Node name (e.g., &quot;<em>net1&quot;, &quot;</em>net2&quot;)</li></ul><p><strong>Returns</strong></p><ul><li>For DC: Float64 voltage</li><li>For AC: Vector{ComplexF64} voltage vs frequency</li><li>For Transient: Vector{Float64} voltage vs time</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">dc = simulate_qucsator(circ, DCAnalysis())
v_out = get_node_voltage(dc, &quot;_net1&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/parser/simulation_result.jl#L1-L23">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.get_pin_current-Tuple{Union{ACResult, DCResult, TransientResult}, Any, Symbol}"><a class="docstring-binding" href="#CircuitSim.get_pin_current-Tuple{Union{ACResult, DCResult, TransientResult}, Any, Symbol}"><code>CircuitSim.get_pin_current</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_pin_current(result, component, pin::Symbol)</code></pre><p>Get current flowing INTO a specific pin of a component from the external circuit.</p><p>Current direction convention:</p><ul><li>Positive current = current flowing INTO the pin (from external circuit)</li><li>Negative current = current flowing OUT of the pin (to external circuit)</li></ul><p>For a voltage source delivering power:</p><ul><li>Current OUT of nplus (to circuit) → get<em>pin</em>current returns NEGATIVE</li><li>Current INTO nminus (from circuit) → get<em>pin</em>current returns POSITIVE</li></ul><p>This follows standard node current convention where currents entering a node are positive.</p><p><strong>Arguments</strong></p><ul><li><code>result</code>: DCResult, ACResult, or TransientResult</li><li><code>component</code>: Component instance (must be a voltage or current source)</li><li><code>pin::Symbol</code>: Pin name (e.g., :nplus, :nminus, :n1, :n2)</li></ul><p><strong>Returns</strong></p><ul><li>For DC: Float64 current (in amperes)</li><li>For AC: Vector{ComplexF64} current vs frequency</li><li>For Transient: Vector{Float64} current vs time</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">V = DCVoltageSource(&quot;V1&quot;, 10.0)
R = Resistor(&quot;R&quot;, 100.0)
# ... build circuit: V.nplus -&gt; R -&gt; GND, V.nminus -&gt; GND ...
dc = simulate_qucsator(circ, DCAnalysis())

# For a source delivering 100mA:
i_nplus = get_pin_current(dc, V, :nplus)   # -100mA (current OUT of source)
i_nminus = get_pin_current(dc, V, :nminus) # +100mA (current INTO source)

# Kirchhoff&#39;s current law: i_nplus + i_nminus = 0</code></pre><p><strong>Note</strong></p><p>Only voltage and current sources report currents in qucsator. For other components, current can be calculated using Ohm&#39;s law with voltage and component parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/parser/simulation_result.jl#L66-L111">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.get_pin_voltage-Tuple{Union{ACResult, DCResult, TransientResult}, Any, Symbol}"><a class="docstring-binding" href="#CircuitSim.get_pin_voltage-Tuple{Union{ACResult, DCResult, TransientResult}, Any, Symbol}"><code>CircuitSim.get_pin_voltage</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_pin_voltage(result, component, pin::Symbol)</code></pre><p>Get voltage at a specific pin of a component.</p><p><strong>Arguments</strong></p><ul><li><code>result</code>: DCResult, ACResult, or TransientResult</li><li><code>component</code>: Component instance (e.g., R1, C1)</li><li><code>pin::Symbol</code>: Pin name (e.g., :n1, :n2, :nplus, :nminus)</li></ul><p><strong>Returns</strong></p><ul><li>For DC: Float64 voltage</li><li>For AC: Vector{ComplexF64} voltage</li><li>For Transient: Vector{Float64} voltage vs time</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">R1 = Resistor(&quot;R1&quot;, 100.0)
# ... build and simulate circuit ...
dc = simulate_qucsator(circ, DCAnalysis())
v_r1_input = get_pin_voltage(dc, R1, :n1)
v_r1_output = get_pin_voltage(dc, R1, :n2)
v_across_r1 = v_r1_input - v_r1_output</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/parser/simulation_result.jl#L154-L181">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.get_probe_current-Tuple{Union{ACResult, DCResult, TransientResult}, Any}"><a class="docstring-binding" href="#CircuitSim.get_probe_current-Tuple{Union{ACResult, DCResult, TransientResult}, Any}"><code>CircuitSim.get_probe_current</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_probe_current(result, probe)</code></pre><p>Get current measured by a CurrentProbe.</p><p><strong>Arguments</strong></p><ul><li><code>result</code>: DCResult, ACResult, or TransientResult</li><li><code>probe</code>: CurrentProbe instance or probe name as String</li></ul><p><strong>Returns</strong></p><ul><li>For DC: Float64 current</li><li>For AC: Vector{ComplexF64} current vs frequency</li><li>For Transient: Vector{Float64} current vs time</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">IP = CurrentProbe(&quot;IP1&quot;)
# ... build circuit with probe ...
dc = simulate_qucsator(circ, DCAnalysis())
i_measured = get_probe_current(dc, IP)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/parser/simulation_result.jl#L300-L324">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.get_probe_voltage-Tuple{Union{ACResult, DCResult, TransientResult}, Any}"><a class="docstring-binding" href="#CircuitSim.get_probe_voltage-Tuple{Union{ACResult, DCResult, TransientResult}, Any}"><code>CircuitSim.get_probe_voltage</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_probe_voltage(result, probe)</code></pre><p>Get voltage measured by a VoltageProbe.</p><p><strong>Arguments</strong></p><ul><li><code>result</code>: DCResult, ACResult, or TransientResult</li><li><code>probe</code>: VoltageProbe instance or probe name as String</li></ul><p><strong>Returns</strong></p><ul><li>For DC: Float64 voltage</li><li>For AC: Vector{ComplexF64} voltage vs frequency</li><li>For Transient: Vector{Float64} voltage vs time</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">VP = VoltageProbe(&quot;VP1&quot;)
# ... build circuit with probe ...
dc = simulate_qucsator(circ, DCAnalysis())
v_measured = get_probe_voltage(dc, VP)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/parser/simulation_result.jl#L266-L290">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.get_real_vector-Tuple{QucsDataset, String}"><a class="docstring-binding" href="#CircuitSim.get_real_vector-Tuple{QucsDataset, String}"><code>CircuitSim.get_real_vector</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_real_vector(dataset::QucsDataset, name::String) -&gt; Vector{Float64}</code></pre><p>Extract real parts of a named vector from the dataset.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/parser/qucs_dataset.jl#L311-L315">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.get_s_matrix_size-Tuple{QucsDataset}"><a class="docstring-binding" href="#CircuitSim.get_s_matrix_size-Tuple{QucsDataset}"><code>CircuitSim.get_s_matrix_size</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_s_matrix_size(dataset::QucsDataset) -&gt; Int</code></pre><p>Determine the size of the S-parameter matrix (number of ports).</p><p><strong>Returns</strong></p><ul><li>Number of ports in the S-parameter matrix</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">n_ports = get_s_matrix_size(result)  # Returns 2 for a 2-port network</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/parser/qucs_dataset.jl#L543-L557">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.get_sparameter-Tuple{QucsDataset, Int64, Int64}"><a class="docstring-binding" href="#CircuitSim.get_sparameter-Tuple{QucsDataset, Int64, Int64}"><code>CircuitSim.get_sparameter</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_sparameter(dataset::QucsDataset, i::Int, j::Int) -&gt; Vector{ComplexF64}</code></pre><p>Get S-parameter S[i,j] from dataset.</p><p><strong>Arguments</strong></p><ul><li><code>dataset::QucsDataset</code>: The simulation results</li><li><code>i::Int</code>: Output port number (1-indexed)</li><li><code>j::Int</code>: Input port number (1-indexed)</li></ul><p><strong>Returns</strong></p><ul><li>Vector of complex S-parameter values</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">s21 = get_sparameter(result, 2, 1)  # Forward transmission
s11 = get_sparameter(result, 1, 1)  # Input reflection</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/parser/qucs_dataset.jl#L470-L491">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.get_time-Tuple{QucsDataset}"><a class="docstring-binding" href="#CircuitSim.get_time-Tuple{QucsDataset}"><code>CircuitSim.get_time</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_time(dataset::QucsDataset) -&gt; Vector{Float64}</code></pre><p>Get the time vector for transient analyses.</p><p><strong>Returns</strong></p><ul><li>Vector of time values in seconds</li></ul><p><strong>Throws</strong></p><ul><li>ErrorException if no time vector found</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/parser/qucs_dataset.jl#L449-L461">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.get_voltage_across-Tuple{Union{ACResult, DCResult, TransientResult}, Any, Symbol, Symbol}"><a class="docstring-binding" href="#CircuitSim.get_voltage_across-Tuple{Union{ACResult, DCResult, TransientResult}, Any, Symbol, Symbol}"><code>CircuitSim.get_voltage_across</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_voltage_across(result, component, pin_pos::Symbol, pin_neg::Symbol)</code></pre><p>Get voltage difference across a component (V<em>pos - V</em>neg).</p><p><strong>Arguments</strong></p><ul><li><code>result</code>: DCResult, ACResult, or TransientResult</li><li><code>component</code>: Component instance</li><li><code>pin_pos::Symbol</code>: Positive pin name</li><li><code>pin_neg::Symbol</code>: Negative pin name</li></ul><p><strong>Returns</strong></p><ul><li>For DC: Float64 voltage difference</li><li>For AC: Vector{ComplexF64} voltage</li><li>For Transient: Vector{Float64} voltage difference vs time</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">R1 = Resistor(&quot;R1&quot;, 100.0)
# ... build and simulate circuit ...
dc = simulate_qucsator(circ, DCAnalysis())
v_across_r1 = get_voltage_across(dc, R1, :n1, :n2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/parser/simulation_result.jl#L198-L224">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.has_errors-Tuple{QucsDataset}"><a class="docstring-binding" href="#CircuitSim.has_errors-Tuple{QucsDataset}"><code>CircuitSim.has_errors</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">has_errors(dataset::QucsDataset) -&gt; Bool</code></pre><p>Check if the simulation had any errors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/parser/qucs_dataset.jl#L366-L370">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.list_vectors-Tuple{QucsDataset}"><a class="docstring-binding" href="#CircuitSim.list_vectors-Tuple{QucsDataset}"><code>CircuitSim.list_vectors</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">list_vectors(dataset::QucsDataset) -&gt; Vector{String}</code></pre><p>List all vector names in the dataset.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/parser/qucs_dataset.jl#L356-L360">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.load_csv-Tuple{String}"><a class="docstring-binding" href="#CircuitSim.load_csv-Tuple{String}"><code>CircuitSim.load_csv</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">load_csv(filepath::String) -&gt; FileData</code></pre><p>Load CSV file with two columns: time, value. First row may be header with column names.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/io/file_loader.jl#L113-L118">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.load_file_data-Tuple{String}"><a class="docstring-binding" href="#CircuitSim.load_file_data-Tuple{String}"><code>CircuitSim.load_file_data</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">load_file_data(filepath::String; format::Symbol=:auto) -&gt; FileData</code></pre><p>Load time-series data from CSV or Qucs Dataset file.</p><p><strong>Arguments</strong></p><ul><li><code>filepath</code>: Path to data file</li><li><code>format</code>: Format hint (:auto, :csv, :qucs_dataset)</li></ul><p><strong>Returns</strong></p><ul><li><code>FileData</code> struct with times, samples, and metadata</li></ul><p><strong>Supported Formats</strong></p><p><strong>CSV Format</strong></p><p>Two columns: time, value (comma or semicolon separated) Optional header row with column names</p><p>Example:</p><pre><code class="nohighlight hljs">time,voltage
0.0,0.0
1e-9,1.0
2e-9,0.5</code></pre><p><strong>Qucs Dataset Format</strong></p><p>Native qucsator format with indep/dep blocks</p><p>Example:</p><pre><code class="nohighlight hljs">&lt;Qucs Dataset 1.0.0&gt;
&lt;indep time 4&gt;
  0.0
  1e-9
  2e-9
  3e-9
&lt;/indep&gt;
&lt;dep V1 4&gt;
  0.0
  1.0
  0.5
  0.0
&lt;/dep&gt;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/io/file_loader.jl#L30-L79">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.load_qucs_dataset-Tuple{String}"><a class="docstring-binding" href="#CircuitSim.load_qucs_dataset-Tuple{String}"><code>CircuitSim.load_qucs_dataset</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">load_qucs_dataset(filepath::String) -&gt; FileData</code></pre><p>Load Qucs Dataset format file.</p><p>Format:</p><pre><code class="nohighlight hljs">&lt;Qucs Dataset VERSION&gt;
&lt;indep TIME_NAME N&gt;
  time1
  time2
  ...
&lt;/indep&gt;
&lt;dep VAR_NAME N&gt;
  value1
  value2
  ...
&lt;/dep&gt;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/io/file_loader.jl#L158-L177">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.netlist_ngspice-Tuple{Circuit}"><a class="docstring-binding" href="#CircuitSim.netlist_ngspice-Tuple{Circuit}"><code>CircuitSim.netlist_ngspice</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">netlist_ngspice(c::Circuit) -&gt; String</code></pre><p>Generate a complete SPICE netlist for ngspice simulator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/backends/ngspice.jl#L45-L49">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.netlist_qucs-Tuple{Circuit}"><a class="docstring-binding" href="#CircuitSim.netlist_qucs-Tuple{Circuit}"><code>CircuitSim.netlist_qucs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">netlist_qucs(c::Circuit) -&gt; String</code></pre><p>Generate a complete Qucs netlist for the circuit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/backends/qucsator.jl#L59-L63">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.parse_qucs_dataset-Tuple{AbstractString}"><a class="docstring-binding" href="#CircuitSim.parse_qucs_dataset-Tuple{AbstractString}"><code>CircuitSim.parse_qucs_dataset</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">parse_qucs_dataset(output::AbstractString) -&gt; QucsDataset</code></pre><p>Parse the Qucs dataset format output from qucsator_rf. Returns a QucsDataset containing all parsed vectors and status information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/parser/qucs_dataset.jl#L176-L181">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.parse_qucs_value-Tuple{AbstractString}"><a class="docstring-binding" href="#CircuitSim.parse_qucs_value-Tuple{AbstractString}"><code>CircuitSim.parse_qucs_value</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">parse_qucs_value(s::AbstractString) -&gt; ComplexF64</code></pre><p>Parse a single value from Qucs dataset format. Handles real values like <code>+1.234e+00</code> and complex values like <code>+1.234e+00+j5.678e-01</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/parser/qucs_dataset.jl#L144-L149">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.pinid-Tuple{Pin}"><a class="docstring-binding" href="#CircuitSim.pinid-Tuple{Pin}"><code>CircuitSim.pinid</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>unique pin id used in union-find:</p><pre><code class="language-julia hljs">hash( (objectid(comp), field) )</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/pin.jl#L11-L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.prepare_external_files!-Tuple{AbstractCircuitComponent, String}"><a class="docstring-binding" href="#CircuitSim.prepare_external_files!-Tuple{AbstractCircuitComponent, String}"><code>CircuitSim.prepare_external_files!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">prepare_external_files!(comp::AbstractCircuitComponent, netlist_dir::String)</code></pre><p>Prepare external files (S-parameters, data files, etc.) for a component before simulation. Default implementation does nothing. Components that need external files should implement this method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/backends/qucsator.jl#L35-L40">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.prepare_external_files!-Tuple{FileCurrentSource, String}"><a class="docstring-binding" href="#CircuitSim.prepare_external_files!-Tuple{FileCurrentSource, String}"><code>CircuitSim.prepare_external_files!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">prepare_external_files!(comp::FileCurrentSource, netlist_dir::String)</code></pre><p>Create data file for FileCurrentSource in the netlist directory when using vector mode. Called by the backend before running qucsator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/sources/file_current_source.jl#L121-L126">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.prepare_external_files!-Tuple{FileVoltageSource, String}"><a class="docstring-binding" href="#CircuitSim.prepare_external_files!-Tuple{FileVoltageSource, String}"><code>CircuitSim.prepare_external_files!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">prepare_external_files!(comp::FileVoltageSource, netlist_dir::String)</code></pre><p>Create data file for FileVoltageSource in the netlist directory when using vector mode. Called by the backend before running qucsator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/sources/file_voltage_source.jl#L123-L128">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.prepare_external_files!-Tuple{SPfile, String}"><a class="docstring-binding" href="#CircuitSim.prepare_external_files!-Tuple{SPfile, String}"><code>CircuitSim.prepare_external_files!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">prepare_external_files!(comp::SPfile, netlist_dir::String)</code></pre><p>Copy S-parameter file to the netlist directory. Called by the backend before running qucsator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/components/spfile.jl#L113-L118">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.print_summary-Tuple{QucsDataset}"><a class="docstring-binding" href="#CircuitSim.print_summary-Tuple{QucsDataset}"><code>CircuitSim.print_summary</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">print_summary(dataset::QucsDataset)</code></pre><p>Print a summary of the dataset contents.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/parser/qucs_dataset.jl#L375-L379">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.run_ngspice-Tuple{Circuit, AbstractAnalysis}"><a class="docstring-binding" href="#CircuitSim.run_ngspice-Tuple{Circuit, AbstractAnalysis}"><code>CircuitSim.run_ngspice</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">run_ngspice(c::Circuit, analysis::AbstractAnalysis; output_file::String=&quot;&quot;)</code></pre><p>Run ngspice simulation with the given circuit and analysis.</p><p><strong>Arguments</strong></p><ul><li><code>c::Circuit</code>: The circuit to simulate</li><li><code>analysis::AbstractAnalysis</code>: Analysis type (DCAnalysis, ACAnalysis, etc.)</li><li><code>output_file::String=&quot;&quot;</code>: Optional output file path. If empty, uses a temporary file.</li></ul><p><strong>Returns</strong></p><ul><li><code>(success::Bool, output::String, netlist::String)</code></li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">success, output, netlist = run_ngspice(c, DCAnalysis())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/backends/ngspice.jl#L67-L84">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.run_ngspice-Tuple{Circuit, Vector{&lt;:AbstractAnalysis}}"><a class="docstring-binding" href="#CircuitSim.run_ngspice-Tuple{Circuit, Vector{&lt;:AbstractAnalysis}}"><code>CircuitSim.run_ngspice</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">run_ngspice(c::Circuit, analyses::Vector{&lt;:AbstractAnalysis}; output_file::String=&quot;&quot;)</code></pre><p>Run ngspice simulation with multiple analysis types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/backends/ngspice.jl#L139-L143">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.run_qucsator-Tuple{Circuit, AbstractAnalysis}"><a class="docstring-binding" href="#CircuitSim.run_qucsator-Tuple{Circuit, AbstractAnalysis}"><code>CircuitSim.run_qucsator</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">run_qucsator(c::Circuit, analysis::AbstractAnalysis; output_file::String=&quot;&quot;, suppress_warnings::Bool=false)</code></pre><p>Run qucsator simulation with the given circuit and analysis.</p><p><strong>Arguments</strong></p><ul><li><code>c::Circuit</code>: The circuit to simulate</li><li><code>analysis::AbstractAnalysis</code>: Analysis type (DCAnalysis, ACAnalysis, etc.)</li><li><code>output_file::String=&quot;&quot;</code>: Optional output file path. If empty, uses a temporary file.</li><li><code>suppress_warnings::Bool=false</code>: If true, suppress qucsator warnings by redirecting stderr</li></ul><p><strong>Returns</strong></p><ul><li><code>(success::Bool, output::String, netlist::String)</code></li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">success, output, netlist = run_qucsator(c, DCAnalysis())
success, output, netlist = run_qucsator(c, ACAnalysis(1.0, 1e6, 101), suppress_warnings=true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/backends/qucsator.jl#L80-L99">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.run_qucsator-Tuple{Circuit, Vector{&lt;:AbstractAnalysis}}"><a class="docstring-binding" href="#CircuitSim.run_qucsator-Tuple{Circuit, Vector{&lt;:AbstractAnalysis}}"><code>CircuitSim.run_qucsator</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">run_qucsator(c::Circuit, analyses::Vector{&lt;:AbstractAnalysis}; output_file::String=&quot;&quot;, suppress_warnings::Bool=false)</code></pre><p>Run qucsator simulation with multiple analysis types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/backends/qucsator.jl#L167-L171">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.s2z"><a class="docstring-binding" href="#CircuitSim.s2z"><code>CircuitSim.s2z</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">s2z(S::Matrix, z0=50.0) -&gt; Matrix</code></pre><p>Convert S-parameter matrix to Z-parameter matrix for a two-port network.</p><p><strong>Arguments</strong></p><ul><li><code>S</code>: 2x2 S-parameter matrix</li><li><code>z0</code>: Reference impedance (default: 50.0 Ω)</li></ul><p><strong>Returns</strong></p><ul><li>2x2 Z-parameter matrix</li></ul><p><strong>Note</strong></p><p>This conversion uses the standard formula Z = z0<em>(I+S)</em>(I-S)⁻¹. For certain ideal passive networks (e.g., perfect series elements at DC), the matrix (I-S) becomes singular, making Z-parameters undefined. This is a fundamental limitation of the parameter representation, not a numerical issue.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using CircuitSim

julia&gt; z_load = 75.0 + 0.0im;  # 75 Ω resistive load

julia&gt; z0 = 50.0;

julia&gt; gamma = (z_load - z0) / (z_load + z0);  # Reflection coefficient

julia&gt; S = [gamma 0.0; 0.0 0.0];  # One-port (shunt load)

julia&gt; Z = s2z(S, z0);

julia&gt; abs(Z[1,1] - z_load) &lt; 1e-10  # Verify Z11 matches load impedance
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/utilities.jl#L10-L50">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.s2z_series"><a class="docstring-binding" href="#CircuitSim.s2z_series"><code>CircuitSim.s2z_series</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">s2z_series(S::Matrix, z0=50.0) -&gt; ComplexF64</code></pre><p>Extract series impedance from S-parameter matrix for a symmetric two-port network.</p><p>This function uses the S→ABCD conversion approach, which is more robust for series elements than the direct Z-parameter conversion. For a series element, the impedance is the B parameter of the ABCD matrix.</p><p><strong>Arguments</strong></p><ul><li><code>S</code>: 2x2 S-parameter matrix</li><li><code>z0</code>: Reference impedance (default: 50.0 Ω)</li></ul><p><strong>Returns</strong></p><ul><li>Series impedance (complex number)</li></ul><p><strong>Note</strong></p><p>For a perfect open circuit (S21 = 0), this function returns Inf+0im, representing infinite impedance. This avoids singularity issues that occur with direct Z-parameter conversion for open circuits.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using CircuitSim

julia&gt; z0 = 50.0;

julia&gt; z_series = 0.0 - 100.0im;  # 100 Ω capacitive reactance

julia&gt; A, B, C, D = 1.0+0.0im, z_series, 0.0+0.0im, 1.0+0.0im;  # ABCD for series element

julia&gt; denom = A + B/z0 + C*z0 + D;

julia&gt; s11 = (A + B/z0 - C*z0 - D) / denom;

julia&gt; s21 = 2.0 / denom;

julia&gt; S = [s11 s21; s21 s11];  # Symmetric

julia&gt; z_extracted = s2z_series(S, z0);

julia&gt; abs(z_extracted - z_series) &lt; 1e-10  # Verify extracted impedance matches original
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/utilities.jl#L64-L112">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.simulate_qucsator-Tuple{Circuit, ACAnalysis}"><a class="docstring-binding" href="#CircuitSim.simulate_qucsator-Tuple{Circuit, ACAnalysis}"><code>CircuitSim.simulate_qucsator</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">simulate_qucsator(c::Circuit, analysis::ACAnalysis; suppress_warnings::Bool=false) -&gt; ACResult</code></pre><p>Run qucsator AC simulation and return typed AC results.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">ac_result = simulate_qucsator(circ, ACAnalysis(1e6, 1e9, 101))
freqs = ac_result.frequencies_Hz
v_out = ac_result.voltages[&quot;_net1&quot;]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/backends/qucsator.jl#L269-L280">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.simulate_qucsator-Tuple{Circuit, AbstractAnalysis}"><a class="docstring-binding" href="#CircuitSim.simulate_qucsator-Tuple{Circuit, AbstractAnalysis}"><code>CircuitSim.simulate_qucsator</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">simulate_qucsator(c::Circuit, analysis::AbstractAnalysis; suppress_warnings::Bool=false) -&gt; QucsDataset</code></pre><p>Fallback for other analysis types - returns raw QucsDataset.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">dataset = simulate_qucsator(circ, HarmonicBalanceAnalysis(1e9))
dataset = simulate_qucsator(circ, NoiseAnalysis(1e6, 1e9, 101, &quot;out&quot;, &quot;V1&quot;))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/backends/qucsator.jl#L353-L363">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.simulate_qucsator-Tuple{Circuit, DCAnalysis}"><a class="docstring-binding" href="#CircuitSim.simulate_qucsator-Tuple{Circuit, DCAnalysis}"><code>CircuitSim.simulate_qucsator</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">simulate_qucsator(c::Circuit, analysis::DCAnalysis; suppress_warnings::Bool=false) -&gt; DCResultrnings::Bool=false) -&gt; DCResult</code></pre><p>Run qucsator DC simulation and return typed DC results.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">dc_result = simulate_qucsator(circ, DCAnalysis())
v_node = dc_result.voltages[&quot;_net1&quot;]
i_source = dc_result.currents[&quot;V1&quot;]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/backends/qucsator.jl#L241-L252">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.simulate_qucsator-Tuple{Circuit, SParameterAnalysis}"><a class="docstring-binding" href="#CircuitSim.simulate_qucsator-Tuple{Circuit, SParameterAnalysis}"><code>CircuitSim.simulate_qucsator</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">simulate_qucsator(c::Circuit, analysis::SParameterAnalysis; suppress_warnings::Bool=false) -&gt; SParameterResult</code></pre><p>Run qucsator S-parameter simulation and return typed S-parameter results.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">sp_result = simulate_qucsator(circ, SParameterAnalysis(1e9, 10e9, 101))
freqs = sp_result.frequencies_Hz
s21 = sp_result.s_matrix[(2,1)]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/backends/qucsator.jl#L325-L336">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.simulate_qucsator-Tuple{Circuit, TransientAnalysis}"><a class="docstring-binding" href="#CircuitSim.simulate_qucsator-Tuple{Circuit, TransientAnalysis}"><code>CircuitSim.simulate_qucsator</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">simulate_qucsator(c::Circuit, analysis::TransientAnalysis; suppress_warnings::Bool=false) -&gt; TransientResult</code></pre><p>Run qucsator transient simulation and return typed transient results.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">tran_result = simulate_qucsator(circ, TransientAnalysis(1e-3, points=1001))
times = tran_result.time_s
v_out = tran_result.voltages[&quot;_net1&quot;]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/backends/qucsator.jl#L297-L308">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.simulate_qucsator-Tuple{Circuit, Vector{&lt;:AbstractAnalysis}}"><a class="docstring-binding" href="#CircuitSim.simulate_qucsator-Tuple{Circuit, Vector{&lt;:AbstractAnalysis}}"><code>CircuitSim.simulate_qucsator</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">simulate_qucsator(c::Circuit, analyses::Vector{&lt;:AbstractAnalysis}; suppress_warnings::Bool=false) -&gt; MultiAnalysisResult</code></pre><p>Run qucsator simulation with multiple analysis types and return typed results.</p><p>Returns a MultiAnalysisResult containing typed results for each analysis that was run.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Run DC + S-parameter analysis together (DC provides operating point for nonlinear components)
results = simulate_qucsator(circ, [DCAnalysis(), SParameterAnalysis(1e9, 10e9, 101)])

# Access DC results
v_node = results.dc.voltages[&quot;_net1&quot;]
i_source = results.dc.currents[&quot;V1&quot;]

# Access S-parameter results
freqs = results.sparameter.frequencies_Hz
s21 = results.sparameter.s_matrix[(2,1)]

# Raw dataset still available if needed
dataset = results.dataset</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/backends/qucsator.jl#L382-L405">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.to_qucs_analysis"><a class="docstring-binding" href="#CircuitSim.to_qucs_analysis"><code>CircuitSim.to_qucs_analysis</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">to_qucs_analysis(analysis::AbstractAnalysis) -&gt; String</code></pre><p>Convert an analysis struct to a Qucs netlist analysis command string. Must be implemented for each concrete analysis type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/analysis/analysis_types.jl#L34-L39">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.to_qucs_netlist"><a class="docstring-binding" href="#CircuitSim.to_qucs_netlist"><code>CircuitSim.to_qucs_netlist</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">to_qucs_netlist(comp::AbstractCircuitComponent) -&gt; String</code></pre><p>Generate a Qucs netlist line for a component. Must be implemented for each component type in the component&#39;s file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/backends/qucsator.jl#L46-L51">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.to_spice_analysis"><a class="docstring-binding" href="#CircuitSim.to_spice_analysis"><code>CircuitSim.to_spice_analysis</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">to_spice_analysis(analysis::AbstractAnalysis) -&gt; String</code></pre><p>Convert an analysis struct to a SPICE netlist analysis command string. Must be implemented for each concrete analysis type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/analysis/analysis_types.jl#L42-L47">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.to_spice_netlist"><a class="docstring-binding" href="#CircuitSim.to_spice_netlist"><code>CircuitSim.to_spice_netlist</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">to_spice_netlist(comp::AbstractCircuitComponent) -&gt; String</code></pre><p>Generate a SPICE netlist line for a component. Must be implemented for each component type in the component&#39;s file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/backends/ngspice.jl#L32-L37">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.write_csv-Tuple{String, AbstractVector, AbstractVector}"><a class="docstring-binding" href="#CircuitSim.write_csv-Tuple{String, AbstractVector, AbstractVector}"><code>CircuitSim.write_csv</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">write_csv(filepath::String, times::AbstractVector, samples::AbstractVector; 
          time_name=&quot;time&quot;, var_name=&quot;data&quot;)</code></pre><p>Write data to CSV format file (two columns with header).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/io/file_loader.jl#L241-L246">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.write_qucs_dataset-Tuple{String, AbstractVector, AbstractVector}"><a class="docstring-binding" href="#CircuitSim.write_qucs_dataset-Tuple{String, AbstractVector, AbstractVector}"><code>CircuitSim.write_qucs_dataset</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">write_qucs_dataset(filepath::String, times::AbstractVector, samples::AbstractVector;
                   time_name=&quot;time&quot;, var_name=&quot;data&quot;)</code></pre><p>Write data to Qucs Dataset format file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/io/file_loader.jl#L257-L262">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CircuitSim.@connect-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#CircuitSim.@connect-Tuple{Any, Any, Any}"><code>CircuitSim.@connect</code></a> — <span class="docstring-category">Macro</span></summary><section><div><p>Macro to connect using dot syntax: @connect circ a.pin b.pin</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ErikBuer/CircuitSim.jl/blob/b7aa30ce9683abcecee46de78b376e417fdaae4e/src/circuit.jl#L43-L45">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Examples/pin_current/">« Pin Current Example</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Monday 2 February 2026 18:20">Monday 2 February 2026</span>. Using Julia version 1.11.8.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
