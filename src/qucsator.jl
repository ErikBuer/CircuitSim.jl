"""
Check if qucsator_rf is installed and available in PATH.
Returns a tuple (is_installed::Bool, version::String, path::String)
"""
function check_qucsator()
    try
        result = read(`qucsator_rf --version`, String)
        lines = split(result, '\n')
        version_line = ""
        for line in lines
            if occursin("qucsator", lowercase(line)) || occursin("qucs", lowercase(line))
                version_line = strip(line)
                break
            end
        end

        # Get the path to qucsator_rf executable
        path = strip(read(`which qucsator_rf`, String))

        return (true, version_line, path)
    catch e
        return (false, "", "")
    end
end

"""
Module for generating Qucs native netlists from CircuitTypes.jl circuits.

The Qucs netlist format uses:
- Components: `Type:Name node1 node2 Property="value"...`
- Actions: `.Type:Name Property="value"...`

Node "gnd" is the ground reference.
"""

# Helper function to convert node number to Qucs node name
qucs_node(n::Int) = n == 0 ? "gnd" : "_net$n"

"""
    to_qucs_netlist(comp::AbstractComponent) -> String

Generate a Qucs netlist line for a component. Override this for each component type.
"""
function to_qucs_netlist end

function to_qucs_netlist(comp::Resistor)::String
    "R:$(comp.name) $(qucs_node(comp.n1)) $(qucs_node(comp.n2)) R=\"$(format_value(comp.value))\""
end

function to_qucs_netlist(comp::Capacitor)::String
    "C:$(comp.name) $(qucs_node(comp.n1)) $(qucs_node(comp.n2)) C=\"$(format_value(comp.value))\""
end

function to_qucs_netlist(comp::Inductor)::String
    "L:$(comp.name) $(qucs_node(comp.n1)) $(qucs_node(comp.n2)) L=\"$(format_value(comp.value))\""
end

function to_qucs_netlist(comp::DCVoltageSource)::String
    "Vdc:$(comp.name) $(qucs_node(comp.nplus)) $(qucs_node(comp.nminus)) U=\"$(format_value(comp.dc))\""
end

function to_qucs_netlist(comp::DCCurrentSource)::String
    "Idc:$(comp.name) $(qucs_node(comp.nplus)) $(qucs_node(comp.nminus)) I=\"$(format_value(comp.dc))\""
end

function to_qucs_netlist(comp::ACVoltageSource)::String
    "Vac:$(comp.name) $(qucs_node(comp.nplus)) $(qucs_node(comp.nminus)) U=\"$(format_value(comp.ac_mag))\" f=\"$(format_value(comp.freq))\" Phase=\"$(comp.ac_phase)\""
end

function to_qucs_netlist(comp::ACCurrentSource)::String
    "Iac:$(comp.name) $(qucs_node(comp.nplus)) $(qucs_node(comp.nminus)) I=\"$(format_value(comp.ac_mag))\" f=\"$(format_value(comp.freq))\" Phase=\"$(comp.ac_phase)\""
end

function to_qucs_netlist(comp::Ground)::String
    ""  # Ground is implicit at gnd node, no netlist entry needed
end

# Fallback for unsupported components
function to_qucs_netlist(comp::AbstractCircuitComponent)::String
    "# Unsupported component: $(typeof(comp))"
end

"""
    netlist_qucs(c::Circuit) -> String

Generate a complete Qucs netlist for the circuit.
"""
function netlist_qucs(c::Circuit)
    assign_nodes!(c)

    lines = String[]
    push!(lines, "# Qucs netlist generated by CircuitTypes.jl")

    for comp in c.components
        line = to_qucs_netlist(comp)
        if !isempty(line)
            push!(lines, line)
        end
    end

    return join(lines, '\n')
end

"""
    run_qucsator(c::Circuit, analysis::AbstractAnalysis; output_file::String="")

Run qucsator simulation with the given circuit and analysis.

# Arguments
- `c::Circuit`: The circuit to simulate
- `analysis::AbstractAnalysis`: Analysis type (DCAnalysis, ACAnalysis, etc.)
- `output_file::String=""`: Optional output file path. If empty, uses a temporary file.

# Returns
- `(success::Bool, output::String, netlist::String)`

# Example
```julia
success, output, netlist = run_qucsator(c, DCAnalysis())
success, output, netlist = run_qucsator(c, ACAnalysis(1.0, 1e6, 101))
```
"""
function run_qucsator(c::Circuit, analysis::AbstractAnalysis; output_file::String="")
    # Check if qucsator_rf is installed
    is_installed, version, path = check_qucsator()
    if !is_installed
        error("qucsator_rf is not installed or not found in PATH. Please install qucsator_rf first.")
    end

    # Generate netlist
    netlist = netlist_qucs(c)

    # Add analysis command
    analysis_str = to_qucs_analysis(analysis)
    netlist = netlist * "\n" * analysis_str

    # Ensure netlist ends with a newline (required by qucsator parser)
    if !endswith(netlist, '\n')
        netlist = netlist * "\n"
    end

    # Create temporary file for netlist
    netlist_file = tempname() * ".net"
    write(netlist_file, netlist)

    # Determine output file
    use_temp_output = isempty(output_file)
    if use_temp_output
        output_file = tempname() * ".dat"
    end

    try
        # Run qucsator_rf
        result = read(`qucsator_rf -i $netlist_file -o $output_file`, String)

        # Read the output if it exists
        output = ""
        if isfile(output_file)
            output = read(output_file, String)
        else
            output = result
        end

        # Clean up temporary files
        rm(netlist_file, force=true)
        if use_temp_output
            rm(output_file, force=true)
        end

        return (true, output, netlist)
    catch e
        # Clean up on error
        rm(netlist_file, force=true)
        if use_temp_output
            rm(output_file, force=true)
        end
        return (false, "Error running qucsator_rf: $e", netlist)
    end
end

"""
    run_qucsator(c::Circuit, analyses::Vector{<:AbstractAnalysis}; output_file::String="")

Run qucsator simulation with multiple analysis types.
"""
function run_qucsator(c::Circuit, analyses::Vector{<:AbstractAnalysis}; output_file::String="")
    # Check if qucsator_rf is installed
    is_installed, version, path = check_qucsator()
    if !is_installed
        error("qucsator_rf is not installed or not found in PATH. Please install qucsator_rf first.")
    end

    # Generate netlist
    netlist = netlist_qucs(c)

    # Add all analysis commands
    for analysis in analyses
        analysis_str = to_qucs_analysis(analysis)
        netlist = netlist * "\n" * analysis_str
    end

    # Ensure netlist ends with a newline (required by qucsator parser)
    if !endswith(netlist, '\n')
        netlist = netlist * "\n"
    end

    # Create temporary file for netlist
    netlist_file = tempname() * ".net"
    write(netlist_file, netlist)

    # Determine output file
    use_temp_output = isempty(output_file)
    if use_temp_output
        output_file = tempname() * ".dat"
    end

    try
        # Run qucsator_rf
        result = read(`qucsator_rf -i $netlist_file -o $output_file`, String)

        # Read the output if it exists
        output = ""
        if isfile(output_file)
            output = read(output_file, String)
        else
            output = result
        end

        # Clean up temporary files
        rm(netlist_file, force=true)
        if use_temp_output
            rm(output_file, force=true)
        end

        return (true, output, netlist)
    catch e
        # Clean up on error
        rm(netlist_file, force=true)
        if use_temp_output
            rm(output_file, force=true)
        end
        return (false, "Error running qucsator_rf: $e", netlist)
    end
end

"""
    simulate_qucsator(c::Circuit, analysis::AbstractAnalysis) -> QucsDataset

Run qucsator simulation with an analysis struct and parse the results.

# Example
```julia
dataset = simulate_qucsator(c, DCAnalysis())
dataset = simulate_qucsator(c, ACAnalysis(1.0, 1e6, 101))
```
"""
function simulate_qucsator(c::Circuit, analysis::AbstractAnalysis)::QucsDataset
    success, output, netlist = run_qucsator(c, analysis)

    if !success
        # Return a dataset with error status
        return QucsDataset(
            SIM_ERROR,
            "",
            Dict{String,DataVector}(),
            Dict{String,DataVector}(),
            [output],
            String[],
            output
        )
    end

    return parse_qucs_dataset(output)
end

"""
    simulate_qucsator(c::Circuit, analyses::Vector{<:AbstractAnalysis}) -> QucsDataset

Run qucsator simulation with multiple analysis types.
"""
function simulate_qucsator(c::Circuit, analyses::Vector{<:AbstractAnalysis})::QucsDataset
    success, output, netlist = run_qucsator(c, analyses)

    if !success
        return QucsDataset(
            SIM_ERROR,
            "",
            Dict{String,DataVector}(),
            Dict{String,DataVector}(),
            [output],
            String[],
            output
        )
    end

    return parse_qucs_dataset(output)
end

"""
    simulate(c::Circuit, analysis::AbstractAnalysis) -> SimulationResult

Run a qucsator simulation with an analysis struct and return a high-level 
SimulationResult object.

# Arguments
- `c::Circuit`: The circuit to simulate
- `analysis::AbstractAnalysis`: Analysis type (DCAnalysis, ACAnalysis, etc.)

# Returns
- `SimulationResult` with methods to query voltages/currents by component

# Example
```julia
# Build circuit
c = Circuit()
V1 = DCVoltageSource("V1", 10.0)
R1 = Resistor("R1", 1e3)
R2 = Resistor("R2", 1e3)
G = Ground("GND")
add_component!(c, V1)
add_component!(c, R1)
add_component!(c, R2)
add_component!(c, G)
@connect c V1.nplus R1.n1
@connect c R1.n2 R2.n1
@connect c R2.n2 G.n
@connect c V1.nminus G.n

# Run DC analysis
result = simulate(c, DCAnalysis())

# Access results by component
v_supply = voltage(result, V1, :nplus)     # 10.0 V
v_mid = voltage(result, R1, :n2)           # 5.0 V
i_source = current(result, V1)             # Current through V1

# Run AC analysis
result_ac = simulate(c, ACAnalysis(1.0, 1e6, 101))
```
"""
function simulate(c::Circuit, analysis::AbstractAnalysis)::SimulationResult
    dataset = simulate_qucsator(c, analysis)
    return SimulationResult(c, dataset)
end

"""
    simulate(c::Circuit, analyses::Vector{<:AbstractAnalysis}) -> SimulationResult

Run a qucsator simulation with multiple analysis types.
"""
function simulate(c::Circuit, analyses::Vector{<:AbstractAnalysis})::SimulationResult
    dataset = simulate_qucsator(c, analyses)
    return SimulationResult(c, dataset)
end