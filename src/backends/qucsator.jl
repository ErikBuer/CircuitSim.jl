"""
    check_qucsator() -> (Bool, String, String)

Check if qucsator_rf is installed and available in PATH.

# Returns
- `is_installed::Bool`: Whether qucsator_rf is available
- `version::String`: Version string if available
- `path::String`: Path to the executable
"""
function check_qucsator()
    try
        result = read(`qucsator_rf --version`, String)
        lines = split(result, '\n')
        version_line = ""
        for line in lines
            if occursin("qucsator", lowercase(line)) || occursin("qucs", lowercase(line))
                version_line = strip(line)
                break
            end
        end

        # Get the path to qucsator_rf executable
        path = strip(read(`which qucsator_rf`, String))

        return (true, version_line, path)
    catch e
        return (false, "", "")
    end
end

# Helper function to convert node number to Qucs node name
qucs_node(n::Int) = n == 0 ? "gnd" : "_net$n"

"""
    to_qucs_netlist(comp::AbstractCircuitComponent) -> String

Generate a Qucs netlist line for a component.
Must be implemented for each component type in the component's file.
"""
function to_qucs_netlist end

# Fallback for unsupported components
function to_qucs_netlist(comp::AbstractCircuitComponent)::String
    "# Unsupported component: $(typeof(comp))"
end

"""
    netlist_qucs(c::Circuit) -> String

Generate a complete Qucs netlist for the circuit.
"""
function netlist_qucs(c::Circuit)
    assign_nodes!(c)

    lines = String[]
    push!(lines, "# Qucs netlist generated by CircuitSim.jl")

    for comp in c.components
        line = to_qucs_netlist(comp)
        if !isempty(line)
            push!(lines, line)
        end
    end

    return join(lines, '\n')
end

"""
    run_qucsator(c::Circuit, analysis::AbstractAnalysis; output_file::String="", suppress_warnings::Bool=false)

Run qucsator simulation with the given circuit and analysis.

# Arguments
- `c::Circuit`: The circuit to simulate
- `analysis::AbstractAnalysis`: Analysis type (DCAnalysis, ACAnalysis, etc.)
- `output_file::String=""`: Optional output file path. If empty, uses a temporary file.
- `suppress_warnings::Bool=false`: If true, suppress qucsator warnings by redirecting stderr

# Returns
- `(success::Bool, output::String, netlist::String)`

# Example
```julia
success, output, netlist = run_qucsator(c, DCAnalysis())
success, output, netlist = run_qucsator(c, ACAnalysis(1.0, 1e6, 101), suppress_warnings=true)
```
"""
function run_qucsator(c::Circuit, analysis::AbstractAnalysis; output_file::String="", suppress_warnings::Bool=false)
    # Check if qucsator_rf is installed
    is_installed, version, path = check_qucsator()
    if !is_installed
        error("qucsator_rf is not installed or not found in PATH. Please install qucsator_rf first.")
    end

    # Generate netlist
    netlist = netlist_qucs(c)

    # Add analysis command
    analysis_str = to_qucs_analysis(analysis)
    netlist = netlist * "\n" * analysis_str

    # Ensure netlist ends with a newline (required by qucsator parser)
    if !endswith(netlist, '\n')
        netlist = netlist * "\n"
    end

    # Create temporary directory for netlist and related files
    netlist_dir = mktempdir()
    netlist_file = joinpath(netlist_dir, "circuit.net")
    write(netlist_file, netlist)

    # Create symlinks/data files for components with external files
    # This is necessary because qucsator cannot handle absolute paths or spaces
    for comp in c.components
        if comp isa AbstractSParameterFile
            # SPfile: create symlink to S-parameter file
            src_file = abspath(comp.file)
            link_name = joinpath(netlist_dir, "$(comp.name).s$(comp.num_ports)p")
            if !ispath(link_name)
                symlink(src_file, link_name)
            end
        elseif hasproperty(comp, :time_vector) && hasproperty(comp, :voltage_vector) && comp.file === nothing
            # FileVoltageSource in vector mode: create data file
            ext = comp.format == :csv ? ".csv" : ".dat"
            data_file = joinpath(netlist_dir, "vfile_$(comp.name)_data$(ext)")
            if comp.format == :csv
                write_csv(data_file, comp.time_vector, comp.voltage_vector,
                    time_name="time", var_name="V.$(comp.name)")
            elseif comp.format == :qucs_dataset
                write_qucs_dataset(data_file, comp.time_vector, comp.voltage_vector,
                    time_name="time", var_name="V.$(comp.name)")
            end
        elseif hasproperty(comp, :time_vector) && hasproperty(comp, :current_vector) && comp.file === nothing
            # FileCurrentSource in vector mode: create data file
            ext = comp.format == :csv ? ".csv" : ".dat"
            data_file = joinpath(netlist_dir, "ifile_$(comp.name)_data$(ext)")
            if comp.format == :csv
                write_csv(data_file, comp.time_vector, comp.current_vector,
                    time_name="time", var_name="I.$(comp.name)")
            elseif comp.format == :qucs_dataset
                write_qucs_dataset(data_file, comp.time_vector, comp.current_vector,
                    time_name="time", var_name="I.$(comp.name)")
            end
        end
    end

    # Determine output file
    use_temp_output = isempty(output_file)
    if use_temp_output
        output_file = joinpath(netlist_dir, "output.dat")
    end

    try
        # Run qucsator_rf from the netlist directory
        # This allows SPfile components to find their data files via basename
        result = cd(netlist_dir) do
            if suppress_warnings
                # Redirect stderr to devnull to suppress warnings
                pipeline(`qucsator_rf -i circuit.net -o $(basename(output_file))`, stderr=devnull) |> read |> String
            else
                read(`qucsator_rf -i circuit.net -o $(basename(output_file))`, String)
            end
        end

        # Read the output if it exists
        output = ""
        if isfile(output_file)
            output = read(output_file, String)
        else
            output = result
        end

        # Clean up temporary directory and all files
        rm(netlist_dir, recursive=true, force=true)

        return (true, output, netlist)
    catch e
        # Clean up on error
        rm(netlist_dir, recursive=true, force=true)
        return (false, "Error running qucsator_rf: $e", netlist)
    end
end

"""
    run_qucsator(c::Circuit, analyses::Vector{<:AbstractAnalysis}; output_file::String="", suppress_warnings::Bool=false)

Run qucsator simulation with multiple analysis types.
"""
function run_qucsator(c::Circuit, analyses::Vector{<:AbstractAnalysis}; output_file::String="", suppress_warnings::Bool=false)
    # Check if qucsator_rf is installed
    is_installed, version, path = check_qucsator()
    if !is_installed
        error("qucsator_rf is not installed or not found in PATH. Please install qucsator_rf first.")
    end

    # Generate netlist
    netlist = netlist_qucs(c)

    # Add all analysis commands
    for analysis in analyses
        analysis_str = to_qucs_analysis(analysis)
        netlist = netlist * "\n" * analysis_str
    end

    # Ensure netlist ends with a newline (required by qucsator parser)
    if !endswith(netlist, '\n')
        netlist = netlist * "\n"
    end

    # Create temporary directory for netlist and related files
    netlist_dir = mktempdir()
    netlist_file = joinpath(netlist_dir, "circuit.net")
    write(netlist_file, netlist)

    # Create symlinks/data files for components with external files
    # This is necessary because qucsator cannot handle absolute paths or spaces
    for comp in c.components
        if comp isa AbstractSParameterFile
            # SPfile: create symlink to S-parameter file
            src_file = abspath(comp.file)
            link_name = joinpath(netlist_dir, "$(comp.name).s$(comp.num_ports)p")
            if !ispath(link_name)
                symlink(src_file, link_name)
            end
        elseif hasproperty(comp, :time_vector) && hasproperty(comp, :voltage_vector) && comp.file === nothing
            # FileVoltageSource in vector mode: create data file
            ext = comp.format == :csv ? ".csv" : ".dat"
            data_file = joinpath(netlist_dir, "vfile_$(comp.name)_data$(ext)")
            if comp.format == :csv
                write_csv(data_file, comp.time_vector, comp.voltage_vector,
                    time_name="time", var_name="V.$(comp.name)")
            elseif comp.format == :qucs_dataset
                write_qucs_dataset(data_file, comp.time_vector, comp.voltage_vector,
                    time_name="time", var_name="V.$(comp.name)")
            end
        elseif hasproperty(comp, :time_vector) && hasproperty(comp, :current_vector) && comp.file === nothing
            # FileCurrentSource in vector mode: create data file
            ext = comp.format == :csv ? ".csv" : ".dat"
            data_file = joinpath(netlist_dir, "ifile_$(comp.name)_data$(ext)")
            if comp.format == :csv
                write_csv(data_file, comp.time_vector, comp.current_vector,
                    time_name="time", var_name="I.$(comp.name)")
            elseif comp.format == :qucs_dataset
                write_qucs_dataset(data_file, comp.time_vector, comp.current_vector,
                    time_name="time", var_name="I.$(comp.name)")
            end
        end
    end

    # Determine output file
    use_temp_output = isempty(output_file)
    if use_temp_output
        output_file = joinpath(netlist_dir, "output.dat")
    end

    try
        # Run qucsator_rf from the netlist directory
        # This allows SPfile components to find their data files via basename
        result = cd(netlist_dir) do
            if suppress_warnings
                # Redirect stderr to devnull to suppress warnings
                pipeline(`qucsator_rf -i circuit.net -o $(basename(output_file))`, stderr=devnull) |> read |> String
            else
                read(`qucsator_rf -i circuit.net -o $(basename(output_file))`, String)
            end
        end

        # Read the output if it exists
        output = ""
        if isfile(output_file)
            output = read(output_file, String)
        else
            output = result
        end

        # Clean up temporary directory and all files
        rm(netlist_dir, recursive=true, force=true)

        return (true, output, netlist)
    catch e
        # Clean up on error
        rm(netlist_dir, recursive=true, force=true)
        return (false, "Error running qucsator_rf: $e", netlist)
    end
end

"""
    simulate_qucsator(c::Circuit, analysis::DCAnalysis; suppress_warnings::Bool=false) -> DCResultrnings::Bool=false) -> DCResult

Run qucsator DC simulation and return typed DC results.

# Example
```julia
dc_result = simulate_qucsator(circ, DCAnalysis())
v_node = dc_result.voltages["_net1"]
i_source = dc_result.currents["V1"]
```
"""
function simulate_qucsator(c::Circuit, analysis::DCAnalysis; suppress_warnings::Bool=false)::DCResult
    success, output, netlist = run_qucsator(c, analysis, suppress_warnings=suppress_warnings)

    if !success
        error("DC simulation failed: $output")
    end

    dataset = parse_qucs_dataset(output)

    if has_errors(dataset)
        error("DC simulation returned errors: $(dataset.errors)")
    end

    return extract_dc_result(dataset)
end

"""
    simulate_qucsator(c::Circuit, analysis::ACAnalysis; suppress_warnings::Bool=false) -> ACResult

Run qucsator AC simulation and return typed AC results.

# Example
```julia
ac_result = simulate_qucsator(circ, ACAnalysis(1e6, 1e9, 101))
freqs = ac_result.frequencies_Hz
v_out = ac_result.voltages["_net1"]
```
"""
function simulate_qucsator(c::Circuit, analysis::ACAnalysis; suppress_warnings::Bool=false)::ACResult
    success, output, netlist = run_qucsator(c, analysis, suppress_warnings=suppress_warnings)

    if !success
        error("AC simulation failed: $output")
    end

    dataset = parse_qucs_dataset(output)

    if has_errors(dataset)
        error("AC simulation returned errors: $(dataset.errors)")
    end

    return extract_ac_result(dataset)
end

"""
    simulate_qucsator(c::Circuit, analysis::TransientAnalysis; suppress_warnings::Bool=false) -> TransientResult

Run qucsator transient simulation and return typed transient results.

# Example
```julia
tran_result = simulate_qucsator(circ, TransientAnalysis(1e-3, points=1001))
times = tran_result.time_s
v_out = tran_result.voltages["_net1"]
```
"""
function simulate_qucsator(c::Circuit, analysis::TransientAnalysis; suppress_warnings::Bool=false)::TransientResult
    success, output, netlist = run_qucsator(c, analysis, suppress_warnings=suppress_warnings)

    if !success
        error("Transient simulation failed: $output")
    end

    dataset = parse_qucs_dataset(output)

    if has_errors(dataset)
        error("Transient simulation returned errors: $(dataset.errors)")
    end

    return extract_transient_result(dataset)
end

"""
    simulate_qucsator(c::Circuit, analysis::SParameterAnalysis; suppress_warnings::Bool=false) -> SParameterResult

Run qucsator S-parameter simulation and return typed S-parameter results.

# Example
```julia
sp_result = simulate_qucsator(circ, SParameterAnalysis(1e9, 10e9, 101))
freqs = sp_result.frequencies_Hz
s21 = sp_result.s_matrix[(2,1)]
```
"""
function simulate_qucsator(c::Circuit, analysis::SParameterAnalysis; suppress_warnings::Bool=false)::SParameterResult
    success, output, netlist = run_qucsator(c, analysis, suppress_warnings=suppress_warnings)

    if !success
        error("S-parameter simulation failed: $output")
    end

    dataset = parse_qucs_dataset(output)

    if has_errors(dataset)
        error("S-parameter simulation returned errors: $(dataset.errors)")
    end

    return extract_sparameter_result(dataset, z0=analysis.z0)
end

"""
    simulate_qucsator(c::Circuit, analysis::AbstractAnalysis; suppress_warnings::Bool=false) -> QucsDataset

Fallback for other analysis types - returns raw QucsDataset.

# Example
```julia
dataset = simulate_qucsator(circ, HarmonicBalanceAnalysis(1e9))
dataset = simulate_qucsator(circ, NoiseAnalysis(1e6, 1e9, 101, "out", "V1"))
```
"""
function simulate_qucsator(c::Circuit, analysis::AbstractAnalysis; suppress_warnings::Bool=false)::QucsDataset
    success, output, netlist = run_qucsator(c, analysis, suppress_warnings=suppress_warnings)

    if !success
        return QucsDataset(
            SIM_ERROR,
            "",
            Dict{String,DataVector}(),
            Dict{String,DataVector}(),
            [output],
            String[],
            output
        )
    end

    return parse_qucs_dataset(output)
end

"""
    simulate_qucsator(c::Circuit, analyses::Vector{<:AbstractAnalysis}; suppress_warnings::Bool=false) -> MultiAnalysisResult

Run qucsator simulation with multiple analysis types and return typed results.

Returns a MultiAnalysisResult containing typed results for each analysis that was run.

# Example
```julia
# Run DC + S-parameter analysis together (DC provides operating point for nonlinear components)
results = simulate_qucsator(circ, [DCAnalysis(), SParameterAnalysis(1e9, 10e9, 101)])

# Access DC results
v_node = results.dc.voltages["_net1"]
i_source = results.dc.currents["V1"]

# Access S-parameter results
freqs = results.sparameter.frequencies_Hz
s21 = results.sparameter.s_matrix[(2,1)]

# Raw dataset still available if needed
dataset = results.dataset
```
"""
function simulate_qucsator(c::Circuit, analyses::Vector{<:AbstractAnalysis}; suppress_warnings::Bool=false)::MultiAnalysisResult
    success, output, netlist = run_qucsator(c, analyses, suppress_warnings=suppress_warnings)

    if !success
        error("Multi-analysis simulation failed: $output")
    end

    dataset = parse_qucs_dataset(output)

    if has_errors(dataset)
        error("Multi-analysis simulation returned errors: $(dataset.errors)")
    end

    return MultiAnalysisResult(dataset, analyses)
end